<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width, height=device-height, target-densitydpi=device-dpi" />
    <meta name="application-name" content="rocketer.io" />
    <meta name="description" content="Scenexe.io but bad." />
    <title>Offline Rocketer</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="https://cdn.glitch.global/92cf917f-5d16-4251-8140-4f5181b6661b/favicon.png?v=1679492856483"
    />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            text-shadow: -2px -2px 0 #000, 0 -2px 0 #000, 2px -2px 0 #000, 2px 0 0 #000, 2px 2px 0 #000, 0 2px 0 #000, -2px 2px 0 #000, -2px 0 0 #000;
            font-weight: 700;
            font-family: "Roboto", sans-serif;
            color: white;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
            user-select: none;         /* Standard */
        }
        canvas {
            display: block;
            background-color: #CDCDCD;
        }
        #changelogPreview {
            position: absolute;
            top: 2%;
            left: 1%;
            font-size: max(2vh,10px);
            font-weight: 900;
            line-height: 1.5;
        }
        #hometitle {
            position: absolute;
            top: 4.5%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: max(7vh,35px);
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #subtitle {
            position: absolute;
            top: calc(6.5% + max(3.5vh,17.5px));
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: max(3.5vh,15.25px);
            font-weight: 400;
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #subsubtitle {
            position: absolute;
            top: 35%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 5vh;
            font-weight: 400;
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #gamemodeSelector {
            position: absolute;
            top: 44%;
            left: 50%;
            height: 12%;
            width: 39.5vmin;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 5vh;
            font-weight: 400;
            background-color: #BA0DB1;
            background-image: linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.3) 51%);/*create a lighter shade for the top part of the button, 0.3 determine color*/
            font-size: 4vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border: .5vmin solid black;
            border-radius: 1vmin;
            white-space: nowrap;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #gamemodeTitle {
            position: absolute;
            top: 25%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
        }
        #regionWord {
            position: absolute;
            top: 60%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 2vmin;
        }
        #regionTitle {
            position: absolute;
            top: 83%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 2.5vmin;
        }
        #gamemodeArrow1 {
            position: absolute;
            top: 25%;
            left: 7%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
            font-size: 6vmin;
        }
        #gamemodeArrow2 {
            position: absolute;
            top: 25%;
            left: 93%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
            font-size: 6vmin;
        }
        #regionArrow1 {
            position: absolute;
            top: 83%;
            left: 27%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
        }
        #regionArrow2 {
            position: absolute;
            top: 83%;
            left: 73%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
        }
        h3, h1{
          padding: 0px;
          margin: .5vmin;    
        }
        #full-changelog {
            position: absolute;
            top: 0%;
            left: 0%;
            line-height: 1.5;
            background-color: rgba(0, 0, 0, .5);
            height: 100%;
            width: 100%;
            font-weight: 900;
            display: none;
        }
        #changelogtextdiv {
          padding: 2vmin 3vmin;
          background-color: rgba(0, 0, 0, .5);
          border: .5vmin solid black;
          border-radius: .5vmin;
          position: fixed;
          top: 50%;
          left: 50%;
          -webkit-transform: translateY(-50%) translateX(-50%);
          text-align: center;
        }
        #exit-changelog {
          text-shadow: -2px -2px 0 #000, 0 -2px 0 #000, 2px -2px 0 #000, 2px 0 0 #000, 2px 2px 0 #000, 0 2px 0 #000, -2px 2px 0 #000, -2px 0 0 #000;
          font-weight: 900;
          font-family: "Roboto", sans-serif;
          color: #fff;
          font-size: 1.8vmin;
          border: .5vmin solid black;
          border-radius: 1vmin;
          background-color: rgba(0, 0, 0, .5);
          padding: .5vmin 1vmin;
          /*Hover transition*/
          -webkit-transition: all 0.3s ease-out;
          -moz-transition: all 0.3s ease-out;
          -o-transition: all 0.3s ease-out;
          transition: all 0.3s ease-out;
          cursor: pointer;
        }
        #exit-changelog:hover {
          background-color: rgba(69,69,69,.5);
        }
        #openChangelogButton {
          background:none;
          border:none;
          margin:0;
          padding:0;
          cursor: pointer;
          color: rgb(0, 176, 225);
          display: inline;/*make the button not jump to the next line, so that 'you can view the full changelog' is on the same line as 'here'*/
        }
        #openChangelogButton:hover {
          text-decoration:underline;
          color: rgb(0, 123, 255);
        }
        .debug {/*debug closed by default*/
            display: none;
        }
        .debugopen {/*change to this class to open the debug*/
            position: absolute;
            font-size: max(2.1vh,15px);
            left: 20px;
            display: block;
        }
        #score {
            position: absolute;
            bottom: 3%;
            left: 0%;
            font-size: max(2.5vh,20px); /*the words change size based on browser height, but minimum size is 20px (use max because if 20px more than 2.5vh, then use 20px)*/
            text-align: center;
            width: 100%;
            display: none;
        }
        #mapSize {
            top: 30%;
        }
        #botnumber{
            top: 22%;
        }
        #shapenumber{
            top: 26%;
        }
        #dimension {
            top: 34%;
        }
        #drawnEntities {
            top: 38%;
        }
        #fpsCounter {
            position: absolute;
            top: 18%;
            left: 20px;
            color: #ccc;
            font-size: max(2.1vh,15px);
            display: none;
        }
        #fpsCounter.high { color: #2ecc71; }  /* Green for 60 FPS */
        #fpsCounter.medium { color: #f39c12; } /* Yellow for 30-59 FPS */
        #fpsCounter.low { color: #e74c3c; }   /* Red for <30 FPS */
        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        .death-content {
            background-color: #222;
            padding: 2rem;
            border-radius: 10px;
            border: 2px solid #e74c3c;
        }

        #deathScreen.hidden {
            display: none;
        }

        #restartButton {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        #restartButton:hover {
            background-color: #c0392b;
        }
      
        #tempHomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: grey;
        }
        #playButton {
            position: absolute;
            top: 55%;
            left: calc(50% + 15.3vmin);
            -webkit-transform: translateY(-50%) translateX(-50%);
            background-color: rgb(56, 183, 100);
            color: white;
            border: none;
            padding: 0.5vmin;
            height: 5vmin;
            font-size: 3vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #playButton:hover {
            background-color: #48f083;
        }
        #display-name-input {
            position: absolute;
            top: 55%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            width: 28.5vmin;
            padding-left: 1vmin;
            padding-top: 1.1vmin;
            padding-bottom: 1.1vmin;
            padding-right: 10vmin;
            font-size: 3vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border: .5vmin solid black;
            border-radius: 1vmin;
        }
        /*input box styling*/
        input:focus {
            outline: none;
            border: none;
        }
        ::placeholder {
          color: #b9b9b9;
          opacity: 1; /* Firefox */
        }
        ::-ms-input-placeholder { /* Edge 12 -18 */
          color: #b9b9b9;
        }
    </style>
</head>
<body>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&family=Yantramanav:wght@900&display=swap"
      rel="stylesheet"
    />
    <div id="score">Score: 0</div>
    <div id="mapSize" class="debug">Map: 4000x4000</div>
    <div id="fpsCounter">FPS: 0</div>
    <div id="botnumber" class="debug">Number of enemies: 0</div>
    <div id="shapenumber" class="debug">Number of shapes: 0</div>
    <div id="dimension" class="debug">Dimension: PvE</div>
    <div id="drawnEntities" class="debug">Drawn Entities: xx</div>
    <canvas id="gameCanvas"></canvas>
    <div id="deathScreen" class="hidden">
        <div class="death-content">
            <h1>Game Over!</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>
    <canvas id="homeScreen"></canvas>
    <input enterkeyhint="go" id="display-name-input" placeholder="Display Name" maxlength="50">
    <button id="playButton">PLAY</button>
    <div id="changelogPreview">ALPHA ?.?.?<br>- Loading changelog...<br>you can view the full changelog here</div>
    <div id="hometitle">rocketer 2.0</div>
    <div id="subtitle">ALPHA ?.?.?</div>
    <div id="subsubtitle">Gamemode</div>
    <div id="gamemodeSelector">
        <div id="gamemodeTitle">Connecting...</div>
        <div id="gamemodeArrow1">&lt;</div>
        <div id="gamemodeArrow2">&gt;</div>
        <div id="regionWord">Region</div>
        <div id="regionTitle">local</div>
        <div id="regionArrow1">&lt;</div>
        <div id="regionArrow2">&gt;</div>
    </div>
    <div id="full-changelog">
        <div id="changelogtextdiv">
          <h1>Changelog</h1>
          <hr />
          <p style="overflow: auto; height: 70vh; width: 70vw; text-align: left; font-size: 2vmin;font-weight: 400;">- Loading changelog...</p>
          <hr /><button id="exit-changelog">BACK</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hcanvas = document.getElementById('homeScreen');
        const hctx = hcanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const mapSizeElement = document.getElementById('mapSize');
        const botnumberElement = document.getElementById('botnumber');
        const shapenumberElement = document.getElementById('shapenumber');
        const dimensionElement = document.getElementById('dimension');
        const drawnentitiesElement = document.getElementById('drawnEntities');
        const changelogPreview = document.getElementById('changelogPreview');
        const subtitle = document.getElementById('subtitle');
        const fullchangelog = document.getElementById('full-changelog');
        document.getElementById('exit-changelog').addEventListener("click", () => {
          fullchangelog.style.display = "none";
        });

        // Set canvas to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        hcanvas.width = window.innerWidth;
        hcanvas.height = window.innerHeight;

        // Game variables
        let score = 0;
        const players = [];
        const bullets = [];
        const enemies = [];
        const particles = [];
        const shapes = [];
        let MAX_SHAPES = 50;
        let MAX_BOTS = 10;
        let gamemode = "PvE arena";
        document.getElementById('gamemodeTitle').textContent = gamemode;
        const keys = {};
        
        // Map settings
        let MAP_WIDTH = 4000;
        let MAP_HEIGHT = 4000;
        let cameraX = 0;
        let cameraY = 0;
        
        // Map background
        let GRID_SIZE = 20;
        let GRID_LINE_COLOR = '#C8C8C8';
        
        // FPS counter variables
        let fps = 0;
        const fpsCounter = document.getElementById('fpsCounter');
        let lastFpsUpdate = 0;
        let frameCount = 0;
        //other debug stuff
        let numberOfObjectsDrawn = 0;
        let debugState = "close";
        
        //death stuff
        let isGamePaused = false;

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 28;//30 looked a little too big
                this.color = '#00B0E1';
                this.outline = '#0092C3'
                this.speed = 5;
                this.angle = 0;
                const health = 100;
                this.health = health;
                this.maxhealth = health;
                this.healSpeed = health/60/8;//takes 8 seconds to fully heal from 0 to max health
                this.healDelay = 60 * 6;//6 seconds of waiting before healing starts
                this.healingValue = 0;//increases when waiting for healDelay time, when reach same value as healdelay, then start healing
                this.bulletCooldown = 0;
                this.bulletCooldownMax = 30;
                this.score = 0;
                this.barrelLength = 50;
                this.barrelWidth = 20;
                this.barrelOffset = 0;
                this.bulletDamage = 5;
                this.bulletSpeed = 7;
                this.bodyDamage = 3;
                this.bulletPenetration = 10;
            }

            update() {
                // Movement
                let moveX = 0;
                let moveY = 0;

                if (keys['w'] || keys['ArrowUp']) moveY -= this.speed;
                if (keys['s'] || keys['ArrowDown']) moveY += this.speed;
                if (keys['a'] || keys['ArrowLeft']) moveX -= this.speed;
                if (keys['d'] || keys['ArrowRight']) moveX += this.speed;

                // Diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.7071;
                    moveY *= 0.7071;
                }

                this.x += moveX;
                this.y += moveY;

                // Map boundary check
                this.x = Math.max(this.radius, Math.min(MAP_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(MAP_HEIGHT - this.radius, this.y));

                // Angle towards mouse
                const mouseWorldX = mouseX + cameraX;
                const mouseWorldY = mouseY + cameraY;
                this.angle = Math.atan2(mouseWorldY - this.y, mouseWorldX - this.x);

                // Reload
                if (this.bulletCooldown > 0) {
                    this.bulletCooldown--;
                }

                // Shoot if mouse is clicked
                if (mouseDown && this.bulletCooldown === 0) {
                    this.shoot();
                    this.bulletCooldown = this.bulletCooldownMax;
                }
                
                // Centre the camera on the player
                cameraX = this.x - canvas.width / 2;
                cameraY = this.y - canvas.height / 2;
                
                // Keep camera within map bounds (add this as a setting in the future)
                //cameraX = Math.max(0, Math.min(MAP_WIDTH - canvas.width, cameraX));
                //cameraY = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, cameraY));
              
                //HEALING
                if (this.health < this.maxhealth){
                  if (this.healingValue >= this.healDelay){//heal!
                    this.health += this.healSpeed;
                    if (this.health >= this.maxhealth){//finish healing
                      if (this.health > this.maxhealth){//if overhealed
                        this.health = this.maxhealth;
                      }
                      this.healingValue = 0;//reset the healing delay time
                    }
                  }
                  else{//waiting for healdelay timing before start healing
                    this.healingValue++;
                  }
                }
            }

            shoot() {
                const bulletSpeed = this.bulletSpeed;
                const bulletX = this.x + Math.cos(this.angle) * (this.radius + 10);//change 10 to barrelLength - bulletSpeed
                const bulletY = this.y + Math.sin(this.angle) * (this.radius + 10);
                
                bullets.push(new Bullet(
                    bulletX,
                    bulletY,
                    Math.cos(this.angle) * bulletSpeed,
                    Math.sin(this.angle) * bulletSpeed,
                    this
                ));
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw tank barrel
                    ctx.strokeStyle = '#7B7B7B';
                    ctx.fillStyle = '#999999'
                    ctx.lineWidth = 4;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                    ctx.fillRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.strokeRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.restore();
                    
                    // Draw tank body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, dx, dy, owner) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = owner.barrelWidth/2;
                this.color = owner.color;
                this.outline = owner.outline;
                this.owner = owner;
                this.lifetime = 100;
                this.damage = owner.bulletDamage;
                this.health = owner.bulletPenetration;
            }//add bullet offset in the future

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;

                // Check collision with enemies if player's bullet
                if (this.owner instanceof Player) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < this.radius + enemy.radius) {
                            // Hit enemy
                            enemy.health -= this.damage;
                            this.health--;//reduce bullet health
                            if (enemy.health <= 0) {
                                this.owner.score += 10;
                                score += 10;
                                scoreElement.textContent = `Score: ${score}`;
                                createParticles(enemy.x, enemy.y, enemy.color, 15);
                                enemies.splice(i, 1);
                                spawnEnemy();
                            }
                            //return true; // Mark for removal
                        }
                    }
                    for (let i = shapes.length - 1; i >= 0; i--) {
                        const shape = shapes[i];
                        const dist = Math.hypot(this.x - shape.x, this.y - shape.y);

                        if (dist < this.radius + shape.size/2) {
                            shape.health -= this.damage;
                            this.health--;//reduce bullet health
                            if (shape.health <= 0) {
                                // Add score based on shape type
                                const points = shapescores[shape.type];
                                this.owner.score += points;
                                score += points;
                                scoreElement.textContent = `Score: ${score}`;

                                createParticles(shape.x, shape.y, shape.color, 8);
                                shapes.splice(i, 1);
                                setTimeout(spawnShape, 1000); // Respawn after delay
                            }
                            //return true; // Bullet is destroyed
                        }
                    }
                }

                // Check collision with player if enemy's bullet
                if (this.owner instanceof Enemy && players.length > 0) {
                    const player = players[0];
                    const dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < this.radius + player.radius) {
                        player.health -= this.damage;
                        player.healingValue = 0;//reset the healing delay time
                        this.health--;//reduce bullet health
                        if (player.health <= 0) {
                            // Game over
                            showDeathScreen(score);
                        }
                        //else{
                          //return true; // Mark for removal
                        //}
                    }
                }

                // Check out of bounds (now against map size)
                if (this.x < 0 || this.x > MAP_WIDTH || this.y < 0 || this.y > MAP_HEIGHT) {
                    return true;//Mark for removal
                }
              
                //check bullet health (penetration)
                if (this.health <= 0) {
                    return true;//Mark for removal
                }

                // Check lifetime
                if (this.lifetime <= 0) {
                    return true;//Mark for removal
                }

                return false;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    numberOfObjectsDrawn++;
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor() {
                // Spawn at edge of map
                const side = Math.floor(Math.random() * 4);
                switch (side) {
                    case 0: // top
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = -30;
                        break;
                    case 1: // right
                        this.x = MAP_WIDTH + 30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                    case 2: // bottom
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = MAP_HEIGHT + 30;
                        break;
                    case 3: // left
                        this.x = -30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                }
                
                const hslColor = Math.random() * 60;
                const botRadius = 20 + Math.random() * 30;
                this.radius = botRadius;
                this.color = `hsl(${hslColor}, 70%, 50%)`;
                this.outline = `hsl(${hslColor}, 50%, 50%)`;//darker saturation
                this.speed = 1 + Math.random() * 2;
                const health = 100;
                this.health = health;
                this.maxhealth = health;//doesnt change
                this.shootCooldown = Math.floor(Math.random() * 100);
                this.shootCooldownMax = 100;
                this.barrelWidth = botRadius/1.5;
                this.bulletDamage = 2;
                this.bulletPenetration = 5;
            }

            update() {
                // Move towards player
                if (players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }

                // Shoot at player
                if (this.shootCooldown <= 0 && players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const bulletSpeed = 5;
                    
                    bullets.push(new Bullet(
                        this.x,
                        this.y,
                        Math.cos(angle) * bulletSpeed,
                        Math.sin(angle) * bulletSpeed,
                        this
                    ));
                    
                    this.shootCooldown = this.shootCooldownMax;
                } else {
                    this.shootCooldown--;
                }
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw enemy body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }
      
      
                const shapecolors = [
                    '#FC7676', //square
                    '#FFE46B', //triangle
                    '#768CFC',  //pentagon
                    '#FCA644', //hexagon
                    '#38B764', //heptagon
                    '#4A66BD', //octagon
                    '#5D275D', //nonagon
                    '#1A1C2C',//decagon
                    '#060011',//hendecagon
                    '#403645',//dodecagon
                    '#EDEDFF',//tridecagon
                    '#000000'//tetradecagon
                ];
                const shapeoutlines = [
                    '#DE5858',
                    '#E1C64D',
                    '#586EDE',
                    '#DE8826',
                    '#1A9946',
                    '#2C489F',
                    '#3F093F',
                    '#00000E',
                    '#000000',
                    '#221827',
                    '#CFCFE1',
                    '#000000'
                ];
                const shapehealths = [
                    50,
                    25,//NOTE: triangle is second in the list, but it is the smallest and least health
                    85,
                    170,
                    350,
                    1050,
                    3500,
                    14000,
                    35000,
                    63000,
                    98000,
                    140000
                ];
                const shapesizes = [
                    35,
                    25,
                    70,
                    100,
                    150,
                    200,
                    300,
                    450,
                    675,
                    1100,
                    2020,
                    3500
                ];
                const shapescores = [
                    10,
                    5,
                    20,
                    30,
                    50,
                    150,
                    500,
                    2000,
                    5000,
                    9000,
                    14000,
                    20000
                ]
                const shapeRotationSpeed = [
                  0.002,
                  0.01,
                  0.002,
                  0.0015,
                  0.001,
                  0.0005,
                  0.0004,
                  0.0003,
                  0.0002,
                  0.0001,
                  0.00005,
                  0.00005
                ]//NOTE: 2 IS THE MAXIMUM because 2*Math.PI is 360 degrees
                //add support for bigger shapes in the future
        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const shapeChance = Math.floor(Math.random() * 101); //choose random number from 0 to 100
                let shapetype = 0;  // 0=square, 1=triangle, 2=pentagon, 3=hexagon, 4=heptagon, n=(n+3)sides
                if (shapeChance<15){//15/100 chance
                  shapetype = 0;//spawn a square
                }
                else if (shapeChance<35){//20/100 chance
                  shapetype = 1;//spawn triangle
                }
                else if (shapeChance<50){//15/100 chance
                  shapetype = 2;//spawn penta
                }
                else if (shapeChance<65){//15/100 chance
                  shapetype = 3;//spawn hexa
                }
                else if (shapeChance<74){//9/100 chance
                  shapetype = 4;
                }
                else if (shapeChance<82){//8/100 chance
                  shapetype = 5;
                }
                else if (shapeChance<89){//7/100 chance
                  shapetype = 6;
                }
                else if (shapeChance<94){//5/100 chance
                  shapetype = 7;
                }
                else if (shapeChance<98){//4/100 chance
                  shapetype = 8;
                }
                else if (shapeChance<100){//2/100 chance
                  shapetype = 9;
                }
                else if (shapeChance<101){//1/100 chance
                  shapetype = 10;//spawn tridecagon
                }
                else{
                  console.log("error: invalid shape spawn")
                }
              /*
                else if (shapeChance<101){//tetradecagon and above cannot spawn in FFA (for rocketer)
                  shapetype = 1;
                }
              */
                this.type = shapetype;
                this.size = shapesizes[shapetype];
                this.health = shapehealths[shapetype];
                this.color = shapecolors[shapetype];//note: if shapetype more than 11, just use 11's color and outline (tetradecagon)
                this.outline = shapeoutlines[shapetype];
                this.rotation = Math.random() * Math.PI * 2;//choose a random starting angle
                this.rotationSpeed = shapeRotationSpeed[shapetype] * Math.PI;
                //this.rotationSpeed = (Math.random() - 0.5) * 0.02;
            }

            update() {
                this.rotation += this.rotationSpeed;
            }

            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                if (!this.isOnScreen(screenX, screenY)) return;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.outline;
                ctx.lineJoin = "round";//to make shape corners round
                ctx.lineWidth = 4;

                switch(this.type) {
                    case 0: // Square
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                        break;
                    case 1: // Triangle
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * Math.PI * 2 / 3) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: // All other polygons
                        const shapeSides = this.type + 3; //pentagon is type 2, but 5 sides
                        ctx.beginPath();
                        for (let i = 0; i < shapeSides; i++) {
                            const angle = (i * Math.PI * 2 / shapeSides) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                }

                ctx.restore();
              
                // Draw health bar
                    const healthBarWidth = this.size;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / shapehealths[this.type];
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + healthBarWidth / 2 + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + healthBarWidth / 2 + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                numberOfObjectsDrawn++;
            }

            isOnScreen(x, y) {
                return x + this.size > 0 && x - this.size < canvas.width &&
                       y + this.size > 0 && y - this.size < canvas.height;
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.dx = (Math.random() - 0.5) * 5;
                this.dy = (Math.random() - 0.5) * 5;
                this.lifetime = 30 + Math.random() * 30;
                this.alpha = 1;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;
                this.alpha = this.lifetime / 60;
                return this.lifetime <= 0;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    //make outline more opaque
                    if ((this.alpha + 0.3)>1){
                      ctx.globalAlpha = 1;
                    }
                    else{
                      ctx.globalAlpha = this.alpha + 0.3;
                    }
                    ctx.stroke();
                    ctx.restore();
                    numberOfObjectsDrawn++;
                }
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function spawnEnemy() {
            enemies.push(new Enemy());
        }
        
        function drawGrid() {
            ctx.strokeStyle = GRID_LINE_COLOR;
            ctx.lineWidth = 2;
            
            // Calculate visible grid area
            const startX = Math.floor(cameraX / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(cameraY / GRID_SIZE) * GRID_SIZE;
            
            const endX = Math.min(MAP_WIDTH, startX + canvas.width + GRID_SIZE);
            const endY = Math.min(MAP_HEIGHT, startY + canvas.height + GRID_SIZE);
            
            // Draw vertical lines
            for (let x = startX; x <= endX; x += GRID_SIZE) {
                const screenX = x - cameraX;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = startY; y <= endY; y += GRID_SIZE) {
                const screenY = y - cameraY;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
        }
      
        function drawMapBoundary() {
            // Save the current drawing state
            ctx.save();

            // Draw area outside the map (where camera can go beyond)
            ctx.fillStyle = 'rgba(95, 103, 108, 0.5)'; // Dark gray for out-of-bounds

            // Top border (above y=0)
            ctx.fillRect(-cameraX-canvas.width/2,-cameraY,MAP_WIDTH+canvas.width,Math.min(0, cameraY));//Math.min so that only draw if cameraY < 0

            // Bottom border (below y=MAP_HEIGHT)
            ctx.fillRect(-cameraX-canvas.width/2,MAP_HEIGHT - cameraY,MAP_WIDTH+canvas.width,canvas.height);

            // Left border (left of x=0)
            ctx.fillRect(-cameraX,-cameraY,Math.min(0, cameraX),MAP_HEIGHT);//only draw if cameraX < 0

            // Right border (right of x=MAP_WIDTH)
            ctx.fillRect(MAP_WIDTH - cameraX,-cameraY,canvas.width,MAP_HEIGHT);

            // Restore drawing state
            ctx.restore();
        }
      
        function drawMinimap() {
            //draw the minimap at top left corner of screen
            let mmX = 10;
            let mmY = 10;
            let mmWidth = 150/1000*canvas.height;
            let mmHeight = 150/1000*canvas.height;//size scaling depending on height of browser
            //if rectangular map instad of square
            if (MAP_WIDTH > MAP_HEIGHT){
              mmWidth = mmWidth/MAP_HEIGHT*MAP_WIDTH;
            }
            if (MAP_WIDTH < MAP_HEIGHT){
              mmHeight = mmHeight/MAP_WIDTH*MAP_HEIGHT;
            }
            ctx.fillStyle = "rgba(189,189,189,.5)";
            ctx.strokeStyle = "rgb(90,90,90)";
            ctx.lineWidth = 5/1000*canvas.height;//size scaling depending on height of browser
            ctx.fillRect(mmX, mmY, mmWidth, mmHeight);
            ctx.strokeRect(mmX, mmY, mmWidth, mmHeight);
            //player location on minimap
            ctx.fillStyle = "rgb(90,90,90)"; //player always darkgrey triangle on minimap
            if (players.length > 0) {
                const player = players[0];
                ctx.save();
                ctx.translate((player.x / MAP_WIDTH) * mmWidth + mmX, (player.y / MAP_HEIGHT) * mmHeight + mmY);
                ctx.rotate(player.angle+90/180*Math.PI);//traingle code draws it 90 degrees sideways (note that everything is in radians, not degrees)
                ctx.beginPath();//draw triangle
                let h = 10;
                let w = 7;
                ctx.moveTo(0,-h/2)
                ctx.lineTo(w/2,h/2)
                ctx.lineTo(-w/2,h/2)
                ctx.fill();
                ctx.restore();
            }
        }

        // Mouse tracking (now in screen coordinates)
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            checkForKeybinds(e.key);
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
      
        function checkForKeybinds(key){//pressed a key, check if the key represents anything (except player movement)
          if (key == "m" && players.length > 0){//if ingame and press m
            if (debugState == "open"){//close the debug
              fpsCounter.style.display = "none";
              let allOtherDebugDivs = document.querySelectorAll(".debugopen");
              for(let i = 0; i < allOtherDebugDivs.length; i++){
                document.getElementById(allOtherDebugDivs[i].id).className = "debug";
              }
              debugState = "close";
            }
            else {//open the debug
              fpsCounter.style.display = "block";
              let allOtherDebugDivs = document.querySelectorAll(".debug");
              for(let i = 0; i < allOtherDebugDivs.length; i++){
                document.getElementById(allOtherDebugDivs[i].id).className = "debugopen";
              }
              debugState = "open";
            }
          }
        }
      
        function spawnShape() {
            shapes.push(new Shape(
                Math.random() * MAP_WIDTH,
                Math.random() * MAP_HEIGHT
            ));
        }
      
        function showDeathScreen(finalScore) {
            isGamePaused = true;
            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('deathScreen').classList.remove('hidden');
        }

        function restartGame() {
            document.getElementById('deathScreen').classList.add('hidden');
            resetGame();
            isGamePaused = false;
            gameLoop();//restart the screen updates
        }

        function resetGame() {
            // Clear all game objects
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;

            // Reset player
            if (players.length > 0) {
                players[0].x = MAP_WIDTH / 2;
                players[0].y = MAP_HEIGHT / 2;
                players[0].health = 100;
                players[0].score = 0;
            } else {
                players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            }

            // Reset score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;

            // Spawn initial enemies
            for (let i = 0; i < MAX_BOTS; i++) {
                spawnEnemy();
            }
        }

        // Game initialization
        function init() {
            players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            
            // Spawn initial enemies
            for (let i = 0; i < MAX_BOTS; i++) {
                spawnEnemy();
            }
            
            // Spawn initial shapes
            for (let i = 0; i < MAX_SHAPES; i++) {
                spawnShape();
            }
            
            // Update map size display
            mapSizeElement.textContent = `Map: ${MAP_WIDTH}x${MAP_HEIGHT}`;
            botnumberElement.textContent = `Number of enemies: ${MAX_BOTS}`;
            shapenumberElement.textContent = `Number of shapes: ${MAX_SHAPES}`;
            dimensionElement.textContent = `Dimension: ${gamemode}`;
            document.getElementById('restartButton').addEventListener('click', restartGame);
        }

        // Game loop
        function gameLoop() {
            if (isGamePaused) return;//dont do anything if at death screen
            numberOfObjectsDrawn = 0;
            // Clear canvas by drawing over
            ctx.fillStyle = '#CDCDCD';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawMapBoundary();//draw area outside map (translucent rectangles so that grids also change color)
          
            // Update and draw shapes first, so that they will be drawn below everything else
            shapes.forEach(shape => {
                shape.update();
                shape.draw();
            });
            
            // Update enemies
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            // Update and draw all game objects
            players.forEach(player => {
                player.update();
                player.draw();
            });

            // Update bullets and remove dead ones
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update() && bullets.splice(i, 1);
            }
            bullets.forEach(bullet => bullet.draw());

            // Update particles and remove dead ones (draw particles last so that they are above everything else)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update() && particles.splice(i, 1);
            }
            particles.forEach(particle => particle.draw());

            // Occasionally spawn new enemies
            if (Math.random() < 0.01 && enemies.length < MAX_BOTS) {
                spawnEnemy();
            }
          
            //if debug is open, and if dimension is not crossroads or cavern:
            drawMinimap()
          
            //update debug
            let newtext = `Drawn Entities: ${numberOfObjectsDrawn}`;
            if (drawnentitiesElement.textContent != newtext){//dont update debug 60 times per second, only update when needed (idk if this will change the performance or not)
              drawnentitiesElement.textContent = newtext;
            }
          
            // FPS counter update
            frameCount++;
            const now = performance.now();
            if (now >= lastFpsUpdate + 1000) { // Update every second
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                fpsCounter.textContent = `FPS: ${fps}`;
                fpsCounter.className = 
                  fps >= 60 ? 'high' : 
                  fps >= 30 ? 'medium' : 'low';
            }

            requestAnimationFrame(gameLoop);
        }

        document.getElementById('playButton').addEventListener('click', startGame);
        function startGame(){
          // First time start game
          //remove home screen divs
          document.getElementById('playButton').style.display = "none";
          hcanvas.style.display = "none";
          document.getElementById('display-name-input').style.display = "none";
          changelogPreview.style.display = "none";
          document.getElementById('hometitle').style.display = "none";
          subtitle.style.display = "none";
          document.getElementById('subsubtitle').style.display = "none";
          document.getElementById('gamemodeSelector').style.display = "none";
          //add game divs
          document.getElementById('score').style.display = "block";
          //open debug
          fpsCounter.style.display = "block";
          let allOtherDebugDivs = document.querySelectorAll(".debug");
          for(let i = 0; i < allOtherDebugDivs.length; i++){
            document.getElementById(allOtherDebugDivs[i].id).className = "debugopen";
          }
          debugState = "open";
          //start the game
          init();
          gameLoop();
        }
        function loadChangelog() {//copied from scenexe2 code, thanks cobalt
          return new Promise(function (AS) {
            fetch("/changelog.txt").then(function (AU) {
              return AU.text();
            }).then(function (AU) {
              (function (AP) {
                var AR = "";
                for (var AQ = ("CHANGELOG - " + (WI = AP.split("\n\r\n"))[0]).split("\n"), AB = 0; AB < AQ.length; AB++) {
                  if (!AQ[AB].startsWith("    ")) {
                    AR += AR == "" ? AQ[AB] : "<br />" + AQ[AB];
                  }
                }//get the first paragraph (latest version update) (version updates are separated by an empty line in the changelog txt file)
                let additionaltext = "<br>you can view the full changelog ";//leave a blank space cuz we're adding a word after that
                changelogPreview.innerHTML = AR.replace(/\n/g, "<br />") + additionaltext;//replace text new line with html new line, and add to the div
                
                const hereButton = document.createElement("div");
                hereButton.innerText = "here";
                hereButton.id = "openChangelogButton";
                changelogPreview.appendChild(hereButton);
                hereButton.addEventListener("click", () => {
                  fullchangelog.style.display = "block";
                });
                
                subtitle.textContent = WI[0].split("-", 1)[0].trim();//add the version no. to subtitle div
                //now fix the entire changelog text
                AR = "";
                for (var AX = 0; AX < WI.length; AX++) {
                  if (AR != "") {
                    AR += "<br /><br /><hr />";//add horizontal line in changelog
                  }
                  for (var AF = WI[AX].split("\n"), Az = 0; Az < AF.length; Az++) {
                    var Aj = 0;
                    var S0 = "";
                    for (Aj = 0; AF[Az].startsWith("    ", Aj * 4); Aj++) {
                      S0 += "&emsp;&emsp;";//add paragraph indentation in changelog
                    }
                    if (Az == 0) {
                      AR += "<h3>";//font size
                    } else if (AR != "" && Az != 1) {
                      AR += "<br />";//new line
                    }
                    AR += S0 + AF[Az];
                    if (Az == 0) {
                      AR += "</h3>";
                    }
                  }
                }
                fullchangelog.children[0].children[2].innerHTML = AR.replace(/\n/g, "<br />");
              })(AU.replace(/\r?\n/g, "\r\n"));
              AS();
            });
          });
        }
        loadChangelog();
    </script>
</body>
</html>