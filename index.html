<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width, height=device-height, target-densitydpi=device-dpi" />
    <meta name="application-name" content="rocketer.io" />
    <meta name="description" content="Scenexe.io but bad." />
    <title>Offline Rocketer</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="https://cdn.glitch.global/92cf917f-5d16-4251-8140-4f5181b6661b/favicon.png?v=1679492856483"
    />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            text-shadow: -2px -2px 0 #000, 0 -2px 0 #000, 2px -2px 0 #000, 2px 0 0 #000, 2px 2px 0 #000, 0 2px 0 #000, -2px 2px 0 #000, -2px 0 0 #000;
            font-weight: 700;
            font-family: "Roboto", sans-serif;
            color: white;
        }
        canvas {
            display: block;
            background-color: #CDCDCD;
        }
        .debug {
            position: absolute;
            font-size: max(2.1vh,15px);
            left: 20px;
        }
        #score {
            position: absolute;
            bottom: 3%;
            left: 0%;
            font-size: max(2.5vh,20px); /*the words change size based on browser height, but minimum size is 20px (use max because if 20px more than 2.5vh, then use 20px)*/
            text-align: center;
            width: 100%;
        }
        #mapSize {
            top: 30%;
        }
        #botnumber{
            top: 22%;
        }
        #shapenumber{
            top: 26%;
        }
        #dimension {
            top: 34%;
        }
        #drawnEntities {
            top: 38%;
        }
        #fpsCounter {
            position: absolute;
            top: 18%;
            left: 20px;
            color: #ccc;
            font-size: max(2.1vh,15px);
        }
        #fpsCounter.high { color: #2ecc71; }  /* Green for 60 FPS */
        #fpsCounter.medium { color: #f39c12; } /* Yellow for 30-59 FPS */
        #fpsCounter.low { color: #e74c3c; }   /* Red for <30 FPS */
        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        .death-content {
            background-color: #222;
            padding: 2rem;
            border-radius: 10px;
            border: 2px solid #e74c3c;
        }

        #deathScreen.hidden {
            display: none;
        }

        #restartButton {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        #restartButton:hover {
            background-color: #c0392b;
        }
      
        #tempHomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
        }
        #playButton {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        #playButton:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&family=Yantramanav:wght@900&display=swap"
      rel="stylesheet"
    />
    <div id="score">Score: 0</div>
    <div id="mapSize" class="debug">Map: 4000x4000</div>
    <div id="fpsCounter">FPS: 0</div>
    <div id="botnumber" class="debug">Number of enemies: 0</div>
    <div id="shapenumber" class="debug">Number of shapes: 0</div>
    <div id="dimension" class="debug">Dimension: FFA</div>
    <div id="drawnEntities" class="debug">Drawn Entities: xx</div>
    <canvas id="gameCanvas"></canvas>
    <div id="deathScreen" class="hidden">
        <div class="death-content">
            <h1>Game Over!</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>
    <div id="tempHomeScreen"></div>
    <button id="playButton">Play</button>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const mapSizeElement = document.getElementById('mapSize');
        const botnumberElement = document.getElementById('botnumber');
        const shapenumberElement = document.getElementById('shapenumber');
        const dimensionElement = document.getElementById('dimension');
        const drawnentitiesElement = document.getElementById('drawnEntities');

        // Set canvas to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game variables
        let score = 0;
        const players = [];
        const bullets = [];
        const enemies = [];
        const particles = [];
        const shapes = [];
        let MAX_SHAPES = 50;
        let MAX_BOTS = 0;//10
        let gamemode = "FFA";
        const keys = {};
        
        // Map settings
        let MAP_WIDTH = 4000;
        let MAP_HEIGHT = 4000;
        let cameraX = 0;
        let cameraY = 0;
        
        // Map background
        let GRID_SIZE = 20;
        let GRID_LINE_COLOR = '#C8C8C8';
        
        // FPS counter variables
        let fps = 0;
        let fpsCounter = document.getElementById('fpsCounter');
        let lastFpsUpdate = 0;
        let frameCount = 0;
        //other debug stuff
        let numberOfObjectsDrawn = 0;
        
        //death stuff
        let isGamePaused = false;

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 28;//30 looked a little too big
                this.color = '#00B0E1';
                this.outline = '#0092C3'
                this.speed = 5;
                this.angle = 0;
                const health = 100;
                this.health = health;
                this.maxhealth = health;
                this.bulletCooldown = 0;
                this.bulletCooldownMax = 30;
                this.score = 0;
                this.barrelLength = 50;
                this.barrelWidth = 20;
                this.barrelOffset = 0;
                this.bulletDamage = 30;
                this.bulletSpeed = 7;
                this.bodyDamage = 3;
            }

            update() {
                // Movement
                let moveX = 0;
                let moveY = 0;

                if (keys['w'] || keys['ArrowUp']) moveY -= this.speed;
                if (keys['s'] || keys['ArrowDown']) moveY += this.speed;
                if (keys['a'] || keys['ArrowLeft']) moveX -= this.speed;
                if (keys['d'] || keys['ArrowRight']) moveX += this.speed;

                // Diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.7071;
                    moveY *= 0.7071;
                }

                this.x += moveX;
                this.y += moveY;

                // Map boundary check
                this.x = Math.max(this.radius, Math.min(MAP_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(MAP_HEIGHT - this.radius, this.y));

                // Angle towards mouse
                const mouseWorldX = mouseX + cameraX;
                const mouseWorldY = mouseY + cameraY;
                this.angle = Math.atan2(mouseWorldY - this.y, mouseWorldX - this.x);

                // Reload
                if (this.bulletCooldown > 0) {
                    this.bulletCooldown--;
                }

                // Shoot if mouse is clicked
                if (mouseDown && this.bulletCooldown === 0) {
                    this.shoot();
                    this.bulletCooldown = this.bulletCooldownMax;
                }
                
                // Centre the camera on the player
                cameraX = this.x - canvas.width / 2;
                cameraY = this.y - canvas.height / 2;
                
                // Keep camera within map bounds (will change later once i add some stuff)
                //cameraX = Math.max(0, Math.min(MAP_WIDTH - canvas.width, cameraX));
                //cameraY = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, cameraY));
            }

            shoot() {
                const bulletSpeed = this.bulletSpeed;
                const bulletX = this.x + Math.cos(this.angle) * (this.radius + 10);//change 10 to barrelLength - bulletSpeed
                const bulletY = this.y + Math.sin(this.angle) * (this.radius + 10);
                
                bullets.push(new Bullet(
                    bulletX,
                    bulletY,
                    Math.cos(this.angle) * bulletSpeed,
                    Math.sin(this.angle) * bulletSpeed,
                    this
                ));
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw tank barrel
                    ctx.strokeStyle = '#7B7B7B';
                    ctx.fillStyle = '#999999'
                    ctx.lineWidth = 4;
                  /*
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(
                        screenX + Math.cos(this.angle) * (this.radius + 20),
                        screenY + Math.sin(this.angle) * (this.radius + 20)
                    );
                    ctx.fill();
                    ctx.stroke();
                  */
                  
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                  /*
                    const barrelLength = this.radius + 20;
                    const barrelWidth = this.radius/1.5;
                    const barrelOffset = 0;
                    */
                    ctx.fillRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.strokeRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.restore(); // Restore transformation state
                    
                    // Draw tank body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    
                    //ctx.fillStyle = '#e74c3c';
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    //ctx.fillStyle = '#2ecc71';
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, dx, dy, owner) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = owner.barrelWidth/2;
                this.color = owner.color;
                this.outline = owner.outline;
                this.owner = owner;
                this.lifetime = 100;
                this.damage = owner.bulletDamage;
            }//add bullet offset in the future

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;

                // Check collision with enemies if player's bullet
                if (this.owner instanceof Player) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < this.radius + enemy.radius) {
                            // Hit enemy
                            enemy.health -= this.damage;
                            if (enemy.health <= 0) {
                                this.owner.score += 10;
                                score += 10;
                                scoreElement.textContent = `Score: ${score}`;
                                createParticles(enemy.x, enemy.y, enemy.color, 15);
                                enemies.splice(i, 1);
                                spawnEnemy();
                            }
                            return true; // Mark for removal
                        }
                    }
                    for (let i = shapes.length - 1; i >= 0; i--) {
                        const shape = shapes[i];
                        const dist = Math.hypot(this.x - shape.x, this.y - shape.y);

                        if (dist < this.radius + shape.size/2) {
                            shape.health -= this.damage;
                            if (shape.health <= 0) {
                                // Add score based on shape type
                                const points = shapescores[shape.type];
                                this.owner.score += points;
                                score += points;
                                scoreElement.textContent = `Score: ${score}`;

                                createParticles(shape.x, shape.y, shape.color, 8);
                                shapes.splice(i, 1);
                                setTimeout(spawnShape, 1000); // Respawn after delay
                            }
                            return true; // Bullet is destroyed
                        }
                    }
                }

                // Check collision with player if enemy's bullet
                if (this.owner instanceof Enemy && players.length > 0) {
                    const player = players[0];
                    const dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < this.radius + player.radius) {
                        player.health -= this.damage;
                        if (player.health <= 0) {
                            // Game over
                            //alert(`Game Over! Your score: ${score}`);
                            //document.location.reload();
                            showDeathScreen(score);
                        }
                        //else{
                          return true; // Mark for removal
                        //}
                    }
                }

                // Check out of bounds (now against map size)
                if (this.x < 0 || this.x > MAP_WIDTH || this.y < 0 || this.y > MAP_HEIGHT) {
                    return true;
                }

                // Check lifetime
                if (this.lifetime <= 0) {
                    return true;
                }

                return false;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    numberOfObjectsDrawn++;
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor() {
                // Spawn at edge of map
                const side = Math.floor(Math.random() * 4);
                switch (side) {
                    case 0: // top
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = -30;
                        break;
                    case 1: // right
                        this.x = MAP_WIDTH + 30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                    case 2: // bottom
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = MAP_HEIGHT + 30;
                        break;
                    case 3: // left
                        this.x = -30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                }
                
                const hslColor = Math.random() * 60;
                const botRadius = 20 + Math.random() * 30;
                this.radius = botRadius;
                this.color = `hsl(${hslColor}, 70%, 50%)`;
                this.outline = `hsl(${hslColor}, 50%, 50%)`;//darker saturation
                this.speed = 1 + Math.random() * 2;
                const health = 100;
                this.health = health;
                this.maxhealth = health;//doesnt change
                this.shootCooldown = Math.floor(Math.random() * 100);
                this.shootCooldownMax = 100;
                this.barrelWidth = botRadius/1.5;
                this.bulletDamage = 10;
            }

            update() {
                // Move towards player
                if (players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }

                // Shoot at player
                if (this.shootCooldown <= 0 && players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const bulletSpeed = 5;
                    
                    bullets.push(new Bullet(
                        this.x,
                        this.y,
                        Math.cos(angle) * bulletSpeed,
                        Math.sin(angle) * bulletSpeed,
                        this
                    ));
                    
                    this.shootCooldown = this.shootCooldownMax;
                } else {
                    this.shootCooldown--;
                }
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw enemy body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }
      
      
                const shapecolors = [
                    '#FC7676', //square
                    '#FFE46B', //triangle
                    '#768CFC',  //pentagon
                    '#FCA644', //hexagon
                    '#38B764', //heptagon
                    '#4A66BD', //octagon
                    '#5D275D', //nonagon
                    '#1A1C2C',//decagon
                    '#060011',//hendecagon
                    '#403645',//dodecagon
                    '#EDEDFF',//tridecagon
                    '#000000'//tetradecagon
                ];
                const shapeoutlines = [
                    '#DE5858',
                    '#E1C64D',
                    '#586EDE',
                    '#DE8826',
                    '#1A9946',
                    '#2C489F',
                    '#3F093F',
                    '#00000E',
                    '#000000',
                    '#221827',
                    '#CFCFE1',
                    '#000000'
                ];
                const shapehealths = [
                    50,
                    25,//NOTE: triangle is second in the list, but it is the smallest and least health
                    85,
                    170,
                    350,
                    1050,
                    3500,
                    
                ];
                const shapesizes = [
                    35,
                    25,
                    70,
                    100,
                    150,
                    200
                ];
                const shapescores = [
                    10,
                    5,
                    20,
                    30,
                    50,
                    150,
                    500,
                    2000,
                    5000,
                    9000,
                    14000,
                    20000
                ]
                //add support for bigger shapes in the future
        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const shapetype = Math.floor(Math.random() * 5); // 0=square, 1=triangle, 2=pentagon, 3=hexagon, 4=heptagon, n=(n+3)sides
                this.type = shapetype;
                this.size = shapesizes[shapetype];
                this.health = shapehealths[shapetype];
                this.color = shapecolors[shapetype];//note: if shapetype more than 11, just use 11's color and outline (tetradecagon)
                this.outline = shapeoutlines[shapetype];
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
            }

            update() {
                this.rotation += this.rotationSpeed;
            }

            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                if (!this.isOnScreen(screenX, screenY)) return;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.outline;
                ctx.lineJoin = "round";//to make shape corners round

                switch(this.type) {
                    case 0: // Square
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                        break;
                    case 1: // Triangle
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * Math.PI * 2 / 3) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: // All other polygons
                        const shapeSides = this.type + 3; //pentagon is type 2, but 5 sides
                        ctx.beginPath();
                        for (let i = 0; i < shapeSides; i++) {
                            const angle = (i * Math.PI * 2 / shapeSides) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                }

                ctx.restore();
              
                // Draw health bar
                    const healthBarWidth = this.size;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / shapehealths[this.type];
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + healthBarWidth / 2 + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + healthBarWidth / 2 + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                numberOfObjectsDrawn++;
            }

            isOnScreen(x, y) {
                return x + this.size > 0 && x - this.size < canvas.width &&
                       y + this.size > 0 && y - this.size < canvas.height;
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.dx = (Math.random() - 0.5) * 5;
                this.dy = (Math.random() - 0.5) * 5;
                this.lifetime = 30 + Math.random() * 30;
                this.alpha = 1;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;
                this.alpha = this.lifetime / 60;
                return this.lifetime <= 0;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    numberOfObjectsDrawn++;
                }
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function spawnEnemy() {
            enemies.push(new Enemy());
        }
        
        function drawGrid() {
            ctx.strokeStyle = GRID_LINE_COLOR;
            ctx.lineWidth = 2;
            
            // Calculate visible grid area
            const startX = Math.floor(cameraX / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(cameraY / GRID_SIZE) * GRID_SIZE;
            
            const endX = Math.min(MAP_WIDTH, startX + canvas.width + GRID_SIZE);
            const endY = Math.min(MAP_HEIGHT, startY + canvas.height + GRID_SIZE);
            
            // Draw vertical lines
            for (let x = startX; x <= endX; x += GRID_SIZE) {
                const screenX = x - cameraX;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = startY; y <= endY; y += GRID_SIZE) {
                const screenY = y - cameraY;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
        }
      
        function drawMapBoundary() {
            // Save the current drawing state
            ctx.save();

            // Draw area outside the map (where camera can go beyond)
            ctx.fillStyle = 'rgba(95, 103, 108, 0.5)'; // Dark gray for out-of-bounds

            // Top border (above y=0)
            ctx.fillRect(-cameraX-canvas.width/2,-cameraY,MAP_WIDTH+canvas.width,Math.min(0, cameraY));//Math.min so that only draw if cameraY < 0

            // Bottom border (below y=MAP_HEIGHT)
            ctx.fillRect(-cameraX-canvas.width/2,MAP_HEIGHT - cameraY,MAP_WIDTH+canvas.width,canvas.height);

            // Left border (left of x=0)
            ctx.fillRect(-cameraX,-cameraY,Math.min(0, cameraX),MAP_HEIGHT);//only draw if cameraX < 0

            // Right border (right of x=MAP_WIDTH)
            ctx.fillRect(MAP_WIDTH - cameraX,-cameraY,canvas.width,MAP_HEIGHT);

            // Restore drawing state
            ctx.restore();
        }
      
        function drawMinimap() {
            //draw the minimap at top left corner of screen
            let mmX = 10;
            let mmY = 10;
            let mmWidth = 150/1000*canvas.height;
            let mmHeight = 150/1000*canvas.height;//size scaling depending on height of browser
            //if rectangular map instad of square
            if (MAP_WIDTH > MAP_HEIGHT){
              mmWidth = mmWidth/MAP_HEIGHT*MAP_WIDTH;
            }
            if (MAP_WIDTH < MAP_HEIGHT){
              mmHeight = mmHeight/MAP_WIDTH*MAP_HEIGHT;
            }
            ctx.fillStyle = "rgba(189,189,189,.5)";
            ctx.strokeStyle = "rgb(90,90,90)";
            ctx.lineWidth = 5/1000*canvas.height;//size scaling depending on height of browser
            ctx.fillRect(mmX, mmY, mmWidth, mmHeight);
            ctx.strokeRect(mmX, mmY, mmWidth, mmHeight);
            //player location on minimap
            ctx.fillStyle = "rgb(90,90,90)"; //player always darkgrey triangle on minimap
            if (players.length > 0) {
                const player = players[0];
                ctx.save();
                ctx.translate((player.x / MAP_WIDTH) * mmWidth + mmX, (player.y / MAP_HEIGHT) * mmHeight + mmY);
                ctx.rotate(player.angle+90/180*Math.PI);//traingle code draws it 90 degrees sideways (note that everything is in radians, not degrees)
                ctx.beginPath();//draw triangle
                let h = 10;
                let w = 7;
                ctx.moveTo(0,-h/2)
                ctx.lineTo(w/2,h/2)
                ctx.lineTo(-w/2,h/2)
                ctx.fill();
                ctx.restore();
            }
        }

        // Mouse tracking (now in screen coordinates)
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
      
        function spawnShape() {
            shapes.push(new Shape(
                Math.random() * MAP_WIDTH,
                Math.random() * MAP_HEIGHT
            ));
        }
      
        function showDeathScreen(finalScore) {
            isGamePaused = true;
            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('deathScreen').classList.remove('hidden');
        }

        function restartGame() {
            document.getElementById('deathScreen').classList.add('hidden');
            resetGame();
            isGamePaused = false;
            gameLoop();//restart the screen updates
        }

        function resetGame() {
            // Clear all game objects
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;

            // Reset player
            if (players.length > 0) {
                players[0].x = MAP_WIDTH / 2;
                players[0].y = MAP_HEIGHT / 2;
                players[0].health = 100;
                players[0].score = 0;
            } else {
                players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            }

            // Reset score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;

            // Spawn initial enemies
            for (let i = 0; i < MAX_BOTS; i++) {
                spawnEnemy();
            }
        }

        // Game initialization
        function init() {
            players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            
            // Spawn initial enemies
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
            
            // Spawn initial shapes
            for (let i = 0; i < MAX_SHAPES; i++) {
                spawnShape();
            }
            
            // Update map size display
            mapSizeElement.textContent = `Map: ${MAP_WIDTH}x${MAP_HEIGHT}`;
            botnumberElement.textContent = `Number of enemies: ${MAX_BOTS}`;
            shapenumberElement.textContent = `Number of shapes: ${MAX_SHAPES}`;
            dimensionElement.textContent = `Dimension: ${gamemode}`;
            document.getElementById('restartButton').addEventListener('click', restartGame);
        }

        // Game loop
        function gameLoop() {
            if (isGamePaused) return;//dont do anything if at death screen
            numberOfObjectsDrawn = 0;
            // Clear canvas by drawing over
            ctx.fillStyle = '#CDCDCD';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawMapBoundary();//draw area outside map (translucent rectangles so that grids also change color)

            // Update and draw all game objects
            players.forEach(player => {
                player.update();
                player.draw();
            });

            // Update bullets and remove dead ones
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update() && bullets.splice(i, 1);
            }
            bullets.forEach(bullet => bullet.draw());

            // Update enemies
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            // Update particles and remove dead ones
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update() && particles.splice(i, 1);
            }
            particles.forEach(particle => particle.draw());

            // Occasionally spawn new enemies
            if (Math.random() < 0.01 && enemies.length < MAX_BOTS) {
                spawnEnemy();
            }
          
            // Update and draw shapes
            shapes.forEach(shape => {
                shape.update();
                shape.draw();
            });
          
            //if debug is open, and if dimension is not crossroads or cavern:
            drawMinimap()
          
            //update debug
            drawnentitiesElement.textContent = `Drawn Entities: ${numberOfObjectsDrawn}`;
          
            // FPS counter update
            frameCount++;
            const now = performance.now();
            if (now >= lastFpsUpdate + 1000) { // Update every second
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                fpsCounter.textContent = `FPS: ${fps}`;
                fpsCounter.className = 
                  fps >= 60 ? 'high' : 
                  fps >= 30 ? 'medium' : 'low';
            }

            requestAnimationFrame(gameLoop);
        }

        document.getElementById('playButton').addEventListener('click', startGame);
        function startGame(){
          // First time start game
          document.getElementById('playButton').style.display = "none";
          document.getElementById('tempHomeScreen').style.display = "none";
          init();
          gameLoop();
        }
    </script>
</body>
</html>