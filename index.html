<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, width=device-width, height=device-height, target-densitydpi=device-dpi" />
    <meta name="application-name" content="rocketer.io" />
    <meta name="description" content="Scenexe.io but bad." />
    <title>Offline Rocketer</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="https://cdn.glitch.global/92cf917f-5d16-4251-8140-4f5181b6661b/favicon.png?v=1679492856483"
    />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            text-shadow: -2px -2px 0 #000, 0 -2px 0 #000, 2px -2px 0 #000, 2px 0 0 #000, 2px 2px 0 #000, 0 2px 0 #000, -2px 2px 0 #000, -2px 0 0 #000;
            font-weight: 700;
            font-family: "Roboto", sans-serif;
            color: white;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
            user-select: none;         /* Standard */
        }
        canvas {
            display: block;
            background-color: #CDCDCD;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
      
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: grey;
        }
        #changelogPreview {
            position: absolute;
            top: 2%;
            left: 1%;
            font-size: max(2vh,10px);
            font-weight: 900;
            line-height: 1.5;
        }
        #hometitle {
            position: absolute;
            top: 4.5%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: max(7vh,35px);
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #subtitle {
            position: absolute;
            top: calc(6.5% + max(3.5vh,17.5px));
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: max(3.5vh,15.25px);
            font-weight: 400;
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
        }
        #subsubtitle {
            position: absolute;
            top: 35%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 5.5vh;
            font-weight: 400;
            letter-spacing: 0.2vh;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
            font-family: "Yantramanav";
        }
        #gamemodeSelector {
            position: absolute;
            top: 44%;
            left: 50%;
            height: 12%;
            width: 39.5vmin;
            -webkit-transform: translateY(-50%) translateX(-50%);
            background-color: #BA0DB1;
            /*background-image: linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 50%, rgba(225,225,225,0.5) 51%);/*create a lighter shade for the top part of the button, #D82BCF*/
            font-size: 4vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border: .5vmin solid black;
            border-radius: 1vmin;
            white-space: nowrap;
            text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
            transition: all .3s ease-out;
        }
        #gamemodeSelectorLighterColor {
            position: fixed;
            top: 0;
            left: 0;
            height: 50%;
            width: 100%;
            background-color: #d82bcf;
            border-radius: 0.5vmin;
            white-space: nowrap;
            transition: all .3s ease-out;
        }
        #gamemodeTitle {
            position: absolute;
            top: 25%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            transition: font-size .3s ease-out;
        }
        #gamemodeTitle:hover {
            font-size: 4.5vmin;
            cursor: pointer;
        }
        #gamemodeTitleAnimation {
            position: absolute;
            top: 25%;
            left: -50%;
            opacity: 0;/*hide it until animation occurs (this allows two gamemode words to appear during animation when you click the arrow button left or right)*/
            -webkit-transform: translateY(-50%) translateX(-50%);
        }
        #gamemodeTitle.animatePrev{/*change to previous gamemode*/
          animation-name: fadeOutOldGamemodePrev;
          animation-duration: .5s;
        }
        #gamemodeTitle.animateNext{/*change to next gamemode*/
          animation-name: fadeOutOldGamemodeNext;
          animation-duration: .5s;
        }
        #gamemodeTitleAnimation.animatePrev{
          animation-name: fadeInNewGamemodePrev;
          animation-duration: .5s;
        }
        #gamemodeTitleAnimation.animateNext{
          animation-name: fadeInNewGamemodeNext;
          animation-duration: .5s;
        }
        @keyframes fadeOutOldGamemodePrev {
          0% {
            left: 50%;
            opacity: 1;
          }
          50% {
            opacity: 0;
          }
          100% {
            left: 100%;
            opacity: 0;
          }
        }
        @keyframes fadeOutOldGamemodeNext {
          0% {
            left: 50%;
            opacity: 1;
          }
          50% {
            opacity: 0;
          }
          100% {
            left: 0%;
            opacity: 0;
          }
        }
        @keyframes fadeInNewGamemodePrev {
          0% {
            left: 0%;
            opacity: 0;
          }
          50% {
            opacity: 0.3;
          }
          100% {
            left: 50%;
            opacity: 1;
          }
        }
        @keyframes fadeInNewGamemodeNext {
          0% {
            left: 100%;
            opacity: 0;
          }
          50% {
            opacity: 0.3;
          }
          100% {
            left: 50%;
            opacity: 1;
          }
        }
        #regionWord {
            position: absolute;
            top: 60%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 2vmin;
        }
        #regionTitle {
            position: absolute;
            top: 83%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 2.5vmin;
        }
        #gamemodeArrow1 {
            position: absolute;
            top: 25%;
            left: 7%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 6vmin;
            transition: all 0.3s ease-out;
            cursor: pointer;
        }
        #gamemodeArrow2 {
            position: absolute;
            top: 25%;
            left: 93%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            font-size: 6vmin;
            transition: all 0.3s ease-out;
            cursor: pointer;
        }
        #regionArrow1 {
            position: absolute;
            top: 83%;
            left: 27%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
            transition: all 0.3s ease-out;
            /*cursor: pointer;*/
        }
        #regionArrow2 {
            position: absolute;
            top: 83%;
            left: 73%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            color: lightgrey;
            transition: all 0.3s ease-out;
            /*cursor: pointer;*/
        }
        #gamemodeArrow1:hover, #gamemodeArrow2:hover{
          font-size: 7.5vmin;
        }
      /*
        #regionArrow1:hover, #regionArrow2:hover{
          font-size: 5.5vmin;
        }*/
        #ovalAnimation {/*the big black oval that yeets across your screen when you change gamemode*/
          position: fixed;
          top: -45%;
          left: 100%;
          width: 90%;
          height: 190%;
          background-color: black;
          border-radius: 50%;
        }
        #ovalAnimation.left{
          animation-name: yeetLeft;
          animation-duration: 1s;
        }
        #ovalAnimation.right{
          animation-name: yeetRight;
          animation-duration: 1.2s;
        }
        @keyframes yeetLeft {
          from {left: 100%;}
          to {left: -90%;}
        }
        @keyframes yeetRight {
          from {left: -90%;}
          to {left: 100%;}
        }
        h3, h1{
          padding: 0px;
          margin: .5vmin;    
        }
        #full-changelog {
            position: absolute;
            top: 0%;
            left: 0%;
            line-height: 1.5;
            background-color: rgba(0, 0, 0, .5);
            height: 100%;
            width: 100%;
            font-weight: 900;
            display: none;
        }
        #changelogtextdiv {
          padding: 2vmin 3vmin;
          background-color: rgba(0, 0, 0, .5);
          border: .5vmin solid black;
          border-radius: .5vmin;
          position: fixed;
          top: 50%;
          left: 50%;
          -webkit-transform: translateY(-50%) translateX(-50%);
          text-align: center;
        }
        #openChangelogButton {
          background:none;
          border:none;
          margin:0;
          padding:0;
          cursor: pointer;
          color: rgb(0, 176, 225);
          display: inline;/*make the button not jump to the next line, so that 'you can view the full changelog' is on the same line as 'here'*/
        }
        #openChangelogButton:hover {
          text-decoration:underline;
          color: rgb(0, 123, 255);
        }
        .debug {/*debug closed by default*/
            display: none;
        }
        .debugopen {/*change to this class to open the debug*/
            position: absolute;
            font-size: max(2.1vh,15px);
            left: 20px;
            display: block;
        }
        #score {
            position: absolute;
            bottom: 3%;
            left: 0%;
            font-size: max(2.5vh,20px); /*the words change size based on browser height, but minimum size is 20px (use max because if 20px more than 2.5vh, then use 20px)*/
            text-align: center;
            width: 100%;
            display: none;
        }
        #mapSize {
            top: 30%;
        }
        #botnumber{
            top: 22%;
        }
        #shapenumber{
            top: 26%;
        }
        #dimension {
            top: 34%;
        }
        #drawnEntities {
            top: 38%;
        }
        #fpsCounter {
            position: absolute;
            top: 18%;
            left: 20px;
            color: #ccc;
            font-size: max(2.1vh,15px);
            display: none;
        }
        #fpsCounter.high { color: #2ecc71; }  /* Green for 60 FPS */
        #fpsCounter.medium { color: #f39c12; } /* Yellow for 30-59 FPS */
        #fpsCounter.low { color: #e74c3c; }   /* Red for <30 FPS */
        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-weight: 900;
            text-align: center;
            line-height: 0.5;
        }
        .death-content-top {
            position: fixed;
            left: 0;
            bottom: 60%;
            width: 100%;
            height: 30%;
            line-height: 1;
        }
        .death-content-bottom {
            position: fixed;
            left: 0;
            top: 50%;
            width: 100%;
            height: 30%;
        }

        #deathScreen.hidden {
          display: none;
        }

        .deathScreenButton {
            background-color: white;
            color: black;
            padding: .7vmin 1vmin;
            font-size: 2.3vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border: .5vmin solid black;
            border-radius: 1vmin;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        .deathScreenButton:hover {
            background-color: lightgrey;
        }
        #playButton {
            position: absolute;
            top: 55%;
            left: calc(50% + 15.3vmin);
            -webkit-transform: translateY(-50%) translateX(-50%);
            background-color: rgb(56, 183, 100);
            color: white;
            border: none;
            padding: 0.5vmin;
            height: 5vmin;
            font-size: 3vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            animation-name: opacityFade;/*whenever you change the display from none to block*/
            animation-duration: .5s;
        }

        #playButton:hover {
            background-color: #48f083;
        }
        #connecting {
          position: absolute;
          top: 55%;
          left: 50%;
          -webkit-transform: translateY(-50%) translateX(-50%);
          text-align:center;
          font-size: 6vmin;
          font-weight: 900;
          font-family: "Roboto", sans-serif;
          text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
          animation-name: opacityFade;
          animation-duration: .5s;
        }
        @keyframes opacityFade {
          from {opacity: 0;}
          to {opacity: 1;}
        }
        #display-name-input {
            position: absolute;
            top: 55%;
            left: 50%;
            -webkit-transform: translateY(-50%) translateX(-50%);
            width: 28.5vmin;
            padding-left: 1vmin;
            padding-top: 1.1vmin;
            padding-bottom: 1.1vmin;
            padding-right: 10vmin;
            font-size: 3vmin;
            font-weight: 900;
            font-family: "Roboto", sans-serif;
            border: .5vmin solid black;
            border-radius: 1vmin;
            animation-name: opacityFade;
            animation-duration: .5s;
        }
        /*input box styling*/
        input:focus {
            outline: none;
            border: none;
        }
        ::placeholder {
          color: #b9b9b9;
          opacity: 1; /* Firefox */
        }
        ::-ms-input-placeholder { /* Edge 12 -18 */
          color: #b9b9b9;
        }
      .hsFlexbox{/*for the button containers on the home screen*/
        position: fixed;
        align-items: center;
        display: flex;
        flex-direction: column;
        gap: 0.15vmin;
        text-align: center;
      }
      #left-buttons {
        left: 0.15vmin;
        bottom: 0;
      }
      #top-buttons {
        right: 0.15vmin;
        top: 0;
      }
      #right-buttons {
        right: 0.15vmin;
        bottom: 0;
        flex-direction: row;
      }
      #reddit {
        background-color: #f94404;
      }
      #reddit:hover {
        background-color: #f97b4b;
      }
      #discord {
        background-color: #5b64ee;
      }
      #discord:hover {
        background-color: #8b93f1;
      }
      #star {
        background-color: #ffe449;
      }
      #star:hover {
        background-color: #ffec80;
      }
      #person {
        background-color: #0092c3;
      }
      #person:hover {
        background-color: #4db3d5;
      }
      #settings {
        background-color: #888888;
      }
      #settings:hover {
        background-color: #acacac;
      }
      #feedback {
        background-color: #b58eff;
      }
      #feedback:hover {
        background-color: #cbb0ff;
      }
      #reportbug {
        background-color: #fdcdac;
      }
      #reportbug:hover {
        background-color: #fedcc5;
      }
      .hsButtons {
        width: 5.8vmin;
        height: 5.8vmin;
        border: .5vmin solid black;
        border-radius: 1vmin;
        cursor: pointer;
        color: white;
        /*center the icon using flex, cuz text-align center doesnt work for the icon*/
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .hsButtons.text {
        width: fit-content;
        padding-left: 1vmin;
        padding-right: 1vmin;
        font-size: 3vmin;
        font-weight: 700;
        font-family: "Roboto", sans-serif;
        text-shadow: -3px -3px 0 #000, 0 -3px 0 #000, 3px -3px 0 #000, 3px 0 0 #000, 3px 3px 0 #000, 0 3px 0 #000, -3px 3px 0 #000, -3px 0 0 #000;
      }
      .material-icons.hsIcons {
        font-size: 4.5vmin;
        text-shadow: -0.3vmin -0.3vmin 0 #000, 0 -0.3vmin 0 #000, 0.3vmin -0.3vmin 0 #000, 0.3vmin 0 0 #000, 0.3vmin 0.3vmin 0 #000, 0 0.3vmin 0 #000, -0.3vmin 0.3vmin 0 #000, -0.3vmin 0 0 #000;
      }
      .modal{
        line-height: 1.5;
        font-size: 1vmin;
        box-sizing: border-box;
        background-color: rgba(0,0,0,.5);
        border-radius: .5vmin;
        box-shadow: 0 0 0 .4vmin #000;
        color: white;
        font-family: Roboto;
        font-weight: 700;
        left: 50%;
        opacity: 1;
        padding: 2vmin 3vmin;
        position: fixed;
        text-align: center;
        top: 50%;
        -webkit-transform: translateY(-50%) translateX(-50%);
        display:none;
      }
      .modalButton{
        text-shadow: -2px -2px 0 #000, 0 -2px 0 #000, 2px -2px 0 #000, 2px 0 0 #000, 2px 2px 0 #000, 0 2px 0 #000, -2px 2px 0 #000, -2px 0 0 #000;
          font-weight: 900;
          font-family: "Roboto", sans-serif;
          color: #fff;
          font-size: 1.8vmin;
          border: .5vmin solid black;
          border-radius: 1vmin;
          background-color: rgba(0, 0, 0, .5);
          padding: .5vmin 1vmin;
          /*Hover transition*/
          -webkit-transition: all 0.3s ease-out;
          -moz-transition: all 0.3s ease-out;
          -o-transition: all 0.3s ease-out;
          transition: all 0.3s ease-out;
          cursor: pointer;
      }
      .modalButton:hover {
          background-color: rgba(69,69,69,.5);
        }
      .modalText{
        box-sizing: border-box;
        font-size: 3.5vmin;
        margin-bottom: .5vmin;
        margin-top: .5vmin;
      }
      .modalTextSmall{
        box-sizing: border-box;
        font-size: 2vmin;
        font-weight: 400;
        margin: 1vmin;
        margin-bottom: .5vmin;
        margin-top: .5vmin;
        max-height: 70vh;
        overflow-y: auto;
        padding: 0.5vw;
      }
      #blackScreen {
            position: absolute;
            top: 0%;
            left: 0%;
            background-color: rgba(0, 0, 0, .5);
            height: 100%;
            width: 100%;
            display: none;
      }
    </style>
</head>
<body>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&family=Yantramanav:wght@400&display=swap"
      rel="stylesheet"
    />
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="mapSize" class="debug">Map: 4000x4000</div>
    <div id="fpsCounter">FPS: 0</div>
    <div id="botnumber" class="debug">Number of enemies: 0</div>
    <div id="shapenumber" class="debug">Number of shapes: 0</div>
    <div id="dimension" class="debug">Dimension: PvE</div>
    <div id="drawnEntities" class="debug">Drawn Entities: xx</div>
    <div id="deathScreen" class="hidden">
        <div class="death-content-top">
            <h1 style="font-size: 5vmin;">You died!</h1>
            <p style="font-size: 2.5vmin;">you were killed by <span id="killer">???</span></p>
        </div>
        <div class="death-content-bottom">
            <p style="font-size: 2.5vmin;">Level <span id="finalLvl">???</span> <span id="playerUpgrade">???-???</span></p>
            <br><p style="font-size: 2.5vmin;">Time Played: <span id="totalTime">??:??:??</span></p>
            <p style="font-size: 2.5vmin;">Score: <span id="finalScore">0</span></p>
            <p style="font-size: 2.5vmin;">Kills: <span id="totalKills">0</span></p>
            <button id="restartButton" class="deathScreenButton">Play Again</button>
            <button id="continueButton" class="deathScreenButton">Continue</button>
        </div>
    </div>
    <canvas id="homeScreen"></canvas>
    <div id="ovalAnimation"></div>
    <div id="connecting">Connecting...</div>
    <input enterkeyhint="go" id="display-name-input" placeholder="Display Name" maxlength="50">
    <button id="playButton">PLAY</button>
    <div id="changelogPreview">ALPHA ?.?.?<br>- Loading changelog...<br>you can view the full changelog here</div>
    <div id="hometitle">rocketer 2.0</div>
    <div id="subtitle">ALPHA ?.?.?</div>
    <div id="subsubtitle">Gamemode</div>
    <div id="gamemodeSelector">
      <div id="gamemodeSelectorLighterColor"></div>
        <div id="gamemodeTitle">Connecting...</div>
        <div id="gamemodeTitleAnimation">Connecting...</div>
        <div id="gamemodeArrow1" onclick="changeGamemode('p')">&lt;</div>
        <div id="gamemodeArrow2" onclick="changeGamemode('n')">&gt;</div>
        <div id="regionWord">Region</div>
        <div id="regionTitle">???</div>
        <div id="regionArrow1">&lt;</div>
        <div id="regionArrow2">&gt;</div>
    </div>
    <div id="left-buttons" class="hsFlexbox">
      <button id="reddit" class="hsButtons">
        <span class="material-icons hsIcons" onclick="window.open('https://www.reddit.com/r/rocketer/')">
        reddit
        </span>
      </button>
      <button id="discord" class="hsButtons">
        <span class="material-icons hsIcons" onclick="window.open('https://discord.com/invite/R83VfCXDFN')">
        discord
        </span>
      </button>
    </div>
    <div id="right-buttons" class="hsFlexbox">
      <button id="feedback" class="hsButtons text" onclick="bugs()">Submit Feedback</button>
      <button id="reportbug" class="hsButtons text" onclick="bugs()">Report Bugs</button>
    </div>
    <div id="top-buttons" class="hsFlexbox">
      <button id="star" class="hsButtons">
        <span class="material-icons hsIcons" onclick="accounts()">
        star
        </span>
      </button>
      <button id="person" class="hsButtons">
        <span class="material-icons hsIcons" onclick="accounts()">
        person
        </span>
      </button>
      <button id="settings" class="hsButtons">
        <span class="material-icons hsIcons" onclick="accounts()">
        settings
        </span>
      </button>
    </div>
    <div id="full-changelog">
        <div id="changelogtextdiv">
          <h1>Changelog</h1>
          <hr />
          <p style="overflow: auto; height: 70vh; width: 70vw; text-align: left; font-size: 2vmin;font-weight: 400;">- Loading changelog...</p>
          <hr /><button id="exit-changelog" class="modalButton">BACK</button>
        </div>
    </div>
    <div id="blackScreen"></div>
    <div id="modal" class="modal"><h1 id="message-popup-title" class="modalText">Error</h1><hr><p id="message-popup-text"  class="modalTextSmall">Accounts will be added soon</p><hr><button id="ok-button" class="modalButton" onclick="closeModal()">OK</button></div>
    <div id="modal2" class="modal"><h1 class="modalText">Feedback/Bugs</h1><hr><p class="modalTextSmall">Please join our Discord server!</p><hr><button class="modalButton" onclick="closeModal2()">OK</button></div>
  
    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hcanvas = document.getElementById('homeScreen');
        const hctx = hcanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const mapSizeElement = document.getElementById('mapSize');
        const botnumberElement = document.getElementById('botnumber');
        const shapenumberElement = document.getElementById('shapenumber');
        const dimensionElement = document.getElementById('dimension');
        const drawnentitiesElement = document.getElementById('drawnEntities');
        const changelogPreview = document.getElementById('changelogPreview');
        const subtitle = document.getElementById('subtitle');
        const fullchangelog = document.getElementById('full-changelog');
        const gamemodeTitle = document.getElementById('gamemodeTitle');
        const gamemodeTitleAnimation = document.getElementById('gamemodeTitleAnimation');//for animating purposes
        const oval = document.getElementById('ovalAnimation');//also for the animation
        document.getElementById('exit-changelog').addEventListener("click", () => {
          fullchangelog.style.display = "none";
        });

        // Set canvas to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        hcanvas.width = window.innerWidth;
        hcanvas.height = window.innerHeight;

        // Game variables
        let score = 0;
        const players = [];
        const bullets = [];
        const enemies = [];
        const particles = [];
        const shapes = [];
        let MAX_SHAPES = 50;
        let MAX_BOTS = 10;
        const gamemodeList = ["PvE arena","Free For All","2 Teams","4 Teams"];
        const gamemodeColorsLight = ["#D82BCF","#F04F54","#BE7FF5","#00E06C"];
        const gamemodeColors = ["#BA0DB1","#D23136","#A061D7","#00C24E"];//for home screen
        const serverLocations = ["local","Sweden","Sweden","Sweden"]
        let currentGamemodeID = 0;//PvE
        let gamemode = gamemodeList[currentGamemodeID];
        document.getElementById('gamemodeSelector').style.backgroundColor = gamemodeColors[currentGamemodeID];
        document.getElementById('gamemodeSelectorLighterColor').style.backgroundColor = gamemodeColorsLight[currentGamemodeID];
        //document.getElementById('gamemodeSelector').style.backgroundImage = "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 50%, " + gamemodeColorsLight[currentGamemodeID] + " 51%)";
        gamemodeTitle.textContent = gamemode;
        regionTitle.textContent = serverLocations[currentGamemodeID];
        if (currentGamemodeID == 0){//no connecting required for PvE
          document.getElementById('connecting').style.display = "none";
        }
        const keys = {};
      
        //function for changing gamemode on home screen
        function changeGamemode(type) {
          if (gamemodeTitle.classList.contains("animateNext")||gamemodeTitle.classList.contains("animateNext")||oval.classList.contains("left")||oval.classList.contains("right")) return;//dont do anything if it is currently animating (might break the current animation)
          if (type == "n"){//next gamemode
            currentGamemodeID++;
            if (currentGamemodeID >= gamemodeList.length){
              currentGamemodeID = 0;
            }
          }
          else if (type == "p"){//previous gamemode
            currentGamemodeID--;
            if (currentGamemodeID < 0){
              currentGamemodeID = (gamemodeList.length - 1);
            }
          }
          gamemode = gamemodeList[currentGamemodeID];
          document.getElementById('gamemodeSelector').style.backgroundColor = gamemodeColors[currentGamemodeID];
          document.getElementById('gamemodeSelectorLighterColor').style.backgroundColor = gamemodeColorsLight[currentGamemodeID];
          //gamemodeTitle.textContent = gamemode;//dont change immediately, only after animation
          gamemodeTitleAnimation.textContent = gamemode;
          regionTitle.textContent = serverLocations[currentGamemodeID];
          if (type == "n"){
            gamemodeTitle.classList.toggle('animateNext');
            gamemodeTitleAnimation.classList.toggle('animateNext');
            oval.classList.toggle('left');//animate it (the big chonky oval that yeets across your screen)
          }
          else{
            gamemodeTitle.classList.toggle('animatePrev');
            gamemodeTitleAnimation.classList.toggle('animatePrev');
            oval.classList.toggle('right');
          }
          if (currentGamemodeID != 0){//not PvE, so need to connect to server
            //remove player button and name input, put connecting...
            document.getElementById('playButton').style.display = "none";
            document.getElementById('display-name-input').style.display = "none";
            document.getElementById('connecting').style.display = "block";
            //might want to animate the gamemode region too...
          }
          else{
            document.getElementById('playButton').style.display = "block";
            document.getElementById('display-name-input').style.display = "block";
            document.getElementById('connecting').style.display = "none";
          }
        }
        gamemodeTitle.addEventListener("animationend", () => {//when finish animating the gamemode selector title after changing gamemode, THEN update the real new gamemode
          gamemodeTitle.textContent = gamemode;
          if (gamemodeTitle.classList.contains("animateNext")){//remove the class to allow new animation
            gamemodeTitle.classList.toggle('animateNext');
            gamemodeTitleAnimation.classList.toggle('animateNext');
          }
          else if (gamemodeTitle.classList.contains("animatePrev")){
            gamemodeTitle.classList.toggle('animatePrev');
            gamemodeTitleAnimation.classList.toggle('animatePrev');
          }
        });
        oval.addEventListener("animationend", () => {//you MUST do this cuz you can't just remove and re-add the class to trigger the animation, browser batches such stuff so animation wont trigger
          if (oval.classList.contains("left")){//if havent remove
            oval.classList.toggle('left');//remove it
          }
          if (oval.classList.contains("right")){//if havent remove
            oval.classList.toggle('right');//remove it
          }
        });
        
        // Map settings
        let MAP_WIDTH = 4000;
        let MAP_HEIGHT = 4000;
        let cameraX = 0;
        let cameraY = 0;
        
        // Map background
        let GRID_SIZE = 24;
        let GRID_LINE_COLOR = '#C8C8C8';
        
        // FPS counter variables
        let fps = 0;
        const fpsCounter = document.getElementById('fpsCounter');
        let lastFpsUpdate = 0;
        let frameCount = 0;
        //other debug stuff
        let numberOfObjectsDrawn = 0;
        let debugState = "close";
        
        //death stuff
        let isGamePaused = false;
      
        //home screen (hs) background canvas stuff
        let hsMAP_SIZE = 3000;
        let rotationRadius = 200;//home screen will move in a circular path, and the radius of this circle is this
        let rotationAngle = 0;//in degree, the angle of the circular path that the map is at now (usedto calculate the x and y coords)
        let hsCameraX = hsMAP_SIZE/2 + rotationRadius  - canvas.width / 2;
        let hsCameraY = hsMAP_SIZE/2  - canvas.height / 2;

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 28;//30 looked a little too big
                this.color = '#00B0E1';
                this.outline = '#0092C3'
                this.speed = 5;
                this.angle = 0;
                const health = 100;
                this.health = health;
                this.maxhealth = health;
                this.healSpeed = health/60/8;//takes 8 seconds to fully heal from 0 to max health
                this.healDelay = 60 * 6;//6 seconds of waiting before healing starts
                this.healingValue = 0;//increases when waiting for healDelay time, when reach same value as healdelay, then start healing
                this.bulletCooldown = 0;
                this.bulletCooldownMax = 30;
                this.score = 0;
                this.barrelLength = 50;
                this.barrelWidth = 20;
                this.barrelOffset = 0;
                this.bulletDamage = 5;
                this.bulletSpeed = 7;
                this.bodyDamage = 3;
                this.bulletPenetration = 10;
            }

            update() {
                // Movement
                let moveX = 0;
                let moveY = 0;

                if (keys['w'] || keys['ArrowUp']) moveY -= this.speed;
                if (keys['s'] || keys['ArrowDown']) moveY += this.speed;
                if (keys['a'] || keys['ArrowLeft']) moveX -= this.speed;
                if (keys['d'] || keys['ArrowRight']) moveX += this.speed;

                // Diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.7071;
                    moveY *= 0.7071;
                }

                this.x += moveX;
                this.y += moveY;

                // Map boundary check
                this.x = Math.max(this.radius, Math.min(MAP_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(MAP_HEIGHT - this.radius, this.y));

                // Angle towards mouse
                const mouseWorldX = mouseX + cameraX;
                const mouseWorldY = mouseY + cameraY;
                this.angle = Math.atan2(mouseWorldY - this.y, mouseWorldX - this.x);

                // Reload
                if (this.bulletCooldown > 0) {
                    this.bulletCooldown--;
                }

                // Shoot if mouse is clicked
                if (mouseDown && this.bulletCooldown === 0) {
                    this.shoot();
                    this.bulletCooldown = this.bulletCooldownMax;
                }
                
                // Centre the camera on the player
                cameraX = this.x - canvas.width / 2;
                cameraY = this.y - canvas.height / 2;
                
                // Keep camera within map bounds (add this as a setting in the future)
                //cameraX = Math.max(0, Math.min(MAP_WIDTH - canvas.width, cameraX));
                //cameraY = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, cameraY));
              
                //HEALING
                if (this.health < this.maxhealth){
                  if (this.healingValue >= this.healDelay){//heal!
                    this.health += this.healSpeed;
                    if (this.health >= this.maxhealth){//finish healing
                      if (this.health > this.maxhealth){//if overhealed
                        this.health = this.maxhealth;
                      }
                      this.healingValue = 0;//reset the healing delay time
                    }
                  }
                  else{//waiting for healdelay timing before start healing
                    this.healingValue++;
                  }
                }
            }

            shoot() {
                const bulletSpeed = this.bulletSpeed;
                const bulletX = this.x + Math.cos(this.angle) * (this.radius + 10);//change 10 to barrelLength - bulletSpeed
                const bulletY = this.y + Math.sin(this.angle) * (this.radius + 10);
                
                bullets.push(new Bullet(
                    bulletX,
                    bulletY,
                    Math.cos(this.angle) * bulletSpeed,
                    Math.sin(this.angle) * bulletSpeed,
                    this
                ));
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw tank barrel
                    ctx.strokeStyle = '#7B7B7B';
                    ctx.fillStyle = '#999999'
                    ctx.lineWidth = 4;
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                    ctx.fillRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.strokeRect(this.barrelOffset,-this.barrelWidth/2,this.barrelLength,this.barrelWidth);
                    ctx.restore();
                    
                    // Draw tank body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, dx, dy, owner) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = owner.barrelWidth/2;
                this.color = owner.color;
                this.outline = owner.outline;
                this.owner = owner;
                this.lifetime = 100;
                this.damage = owner.bulletDamage;
                this.health = owner.bulletPenetration;
            }//add bullet offset in the future

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;

                // Check collision with enemies if player's bullet
                if (this.owner instanceof Player) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < this.radius + enemy.radius) {
                            // Hit enemy
                            enemy.health -= this.damage;
                            this.health--;//reduce bullet health
                            if (enemy.health <= 0) {
                                this.owner.score += 10;
                                score += 10;
                                scoreElement.textContent = `Score: ${score}`;
                                //createParticles(enemy.x, enemy.y, enemy.color, enemy.outline, 15);
                                enemies.splice(i, 1);
                                spawnEnemy();
                            }
                            //return true; // Mark for removal
                        }
                    }
                    for (let i = shapes.length - 1; i >= 0; i--) {
                        const shape = shapes[i];
                        const dist = Math.hypot(this.x - shape.x, this.y - shape.y);

                        if (dist < this.radius + shape.size/2) {
                            shape.health -= this.damage;
                            this.health--;//reduce bullet health
                            if (shape.health <= 0) {
                                // Add score based on shape type
                                const points = shapescores[shape.type];
                                this.owner.score += points;
                                score += points;
                                scoreElement.textContent = `Score: ${score}`;

                                //createParticles(shape.x, shape.y, shape.color, shape.outline, 8);
                                shapes.splice(i, 1);
                                setTimeout(spawnShape, 1000); // Respawn after delay
                            }
                            //return true; // Bullet is destroyed
                        }
                    }
                }

                // Check collision with player if enemy's bullet
                if (this.owner instanceof Enemy && players.length > 0) {
                    const player = players[0];
                    const dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < this.radius + player.radius) {
                        player.health -= this.damage;
                        player.healingValue = 0;//reset the healing delay time
                        this.health--;//reduce bullet health
                        if (player.health <= 0) {
                            // Game over
                            showDeathScreen(score);
                        }
                        //else{
                          //return true; // Mark for removal
                        //}
                    }
                }

                // Check out of bounds (now against map size)
                if (this.x < 0 || this.x > MAP_WIDTH || this.y < 0 || this.y > MAP_HEIGHT) {
                    return true;//Mark for removal
                }
              
                //check bullet health (penetration)
                if (this.health <= 0) {
                    return true;//Mark for removal
                }

                // Check lifetime
                if (this.lifetime <= 0) {
                    return true;//Mark for removal
                }

                return false;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    numberOfObjectsDrawn++;
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor() {
                // Spawn at edge of map
                const side = Math.floor(Math.random() * 4);
                switch (side) {
                    case 0: // top
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = -30;
                        break;
                    case 1: // right
                        this.x = MAP_WIDTH + 30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                    case 2: // bottom
                        this.x = Math.random() * MAP_WIDTH;
                        this.y = MAP_HEIGHT + 30;
                        break;
                    case 3: // left
                        this.x = -30;
                        this.y = Math.random() * MAP_HEIGHT;
                        break;
                }
                
                const hslColor = Math.random() * 60;
                const botRadius = 20 + Math.random() * 30;
                this.radius = botRadius;
                this.color = `hsl(${hslColor}, 70%, 50%)`;
                this.outline = `hsl(${hslColor}, 50%, 50%)`;//darker saturation
                this.speed = 1 + Math.random() * 2;
                const health = 100;
                this.health = health;
                this.maxhealth = health;//doesnt change
                this.shootCooldown = Math.floor(Math.random() * 100);
                this.shootCooldownMax = 100;
                this.barrelWidth = botRadius/1.5;
                this.bulletDamage = 2;
                this.bulletPenetration = 5;
            }

            update() {
                // Move towards player
                if (players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }

                // Shoot at player
                if (this.shootCooldown <= 0 && players.length > 0) {
                    const player = players[0];
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const bulletSpeed = 5;
                    
                    bullets.push(new Bullet(
                        this.x,
                        this.y,
                        Math.cos(angle) * bulletSpeed,
                        Math.sin(angle) * bulletSpeed,
                        this
                    ));
                    
                    this.shootCooldown = this.shootCooldownMax;
                } else {
                    this.shootCooldown--;
                }
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (this.isOnScreen(screenX, screenY)) {
                    // Draw enemy body
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = this.radius * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / this.maxhealth;
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,
                        screenY + this.radius + 15 - 2,
                        healthBarWidth + 4,
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + this.radius + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                    numberOfObjectsDrawn++;
                }
            }
            
            isOnScreen(x, y) {
                return x + this.radius > 0 && x - this.radius < canvas.width &&
                       y + this.radius > 0 && y - this.radius < canvas.height;
            }
        }
      
      
                const shapecolors = [
                    '#FC7676', //square
                    '#FFE46B', //triangle
                    '#768CFC',  //pentagon
                    '#FCA644', //hexagon
                    '#38B764', //heptagon
                    '#4A66BD', //octagon
                    '#5D275D', //nonagon
                    '#1A1C2C',//decagon
                    '#060011',//hendecagon
                    '#403645',//dodecagon
                    '#EDEDFF',//tridecagon
                    '#000000'//tetradecagon
                ];
                const shapeoutlines = [
                    '#DE5858',
                    '#E1C64D',
                    '#586EDE',
                    '#DE8826',
                    '#1A9946',
                    '#2C489F',
                    '#3F093F',
                    '#00000E',
                    '#000000',
                    '#221827',
                    '#CFCFE1',
                    '#000000'
                ];
                const shapehealths = [
                    50,
                    25,//NOTE: triangle is second in the list, but it is the smallest and least health
                    85,
                    170,
                    350,
                    1050,
                    3500,
                    14000,
                    35000,
                    63000,
                    98000,
                    140000
                ];
                const shapesizes = [
                    35,
                    25,
                    70,
                    100,
                    150,
                    200,
                    300,
                    450,
                    675,
                    1100,
                    2020,
                    3500
                ];
                const shapescores = [
                    10,
                    5,
                    20,
                    30,
                    50,
                    150,
                    500,
                    2000,
                    5000,
                    9000,
                    14000,
                    20000
                ]
                const shapeRotationSpeed = [
                  0.002,
                  0.01,
                  0.002,
                  0.0015,
                  0.001,
                  0.0005,
                  0.0004,
                  0.0003,
                  0.0002,
                  0.0001,
                  0.00005,
                  0.00005
                ]//NOTE: 2 IS THE MAXIMUM because 2*Math.PI is 360 degrees
                //add support for bigger shapes in the future
        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const shapeChance = Math.floor(Math.random() * 101); //choose random number from 0 to 100
                let shapetype = 0;  // 0=square, 1=triangle, 2=pentagon, 3=hexagon, 4=heptagon, n=(n+3)sides
                if (shapeChance<15){//15/100 chance
                  shapetype = 0;//spawn a square
                }
                else if (shapeChance<35){//20/100 chance
                  shapetype = 1;//spawn triangle
                }
                else if (shapeChance<50){//15/100 chance
                  shapetype = 2;//spawn penta
                }
                else if (shapeChance<65){//15/100 chance
                  shapetype = 3;//spawn hexa
                }
                else if (shapeChance<74){//9/100 chance
                  shapetype = 4;
                }
                else if (shapeChance<82){//8/100 chance
                  shapetype = 5;
                }
                else if (shapeChance<89){//7/100 chance
                  shapetype = 6;
                }
                else if (shapeChance<94){//5/100 chance
                  shapetype = 7;
                }
                else if (shapeChance<98){//4/100 chance
                  shapetype = 8;
                }
                else if (shapeChance<100){//2/100 chance
                  shapetype = 9;
                }
                else if (shapeChance<101){//1/100 chance
                  shapetype = 10;//spawn tridecagon
                }
                else{
                  console.log("error: invalid shape spawn")
                }
              /*
                else if (shapeChance<101){//tetradecagon and above cannot spawn in FFA (for rocketer)
                  shapetype = 1;
                }
              */
                this.type = shapetype;
                this.size = shapesizes[shapetype];
                this.health = shapehealths[shapetype];
                this.color = shapecolors[shapetype];//note: if shapetype more than 11, just use 11's color and outline (tetradecagon)
                this.outline = shapeoutlines[shapetype];
                this.rotation = Math.random() * Math.PI * 2;//choose a random starting angle
                this.rotationSpeed = shapeRotationSpeed[shapetype] * Math.PI;
                //this.rotationSpeed = (Math.random() - 0.5) * 0.02;
            }

            update() {
                this.rotation += this.rotationSpeed;
            }

            draw() {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                if (!this.isOnScreen(screenX, screenY)) return;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.outline;
                ctx.lineJoin = "round";//to make shape corners round
                ctx.lineWidth = 4;

                switch(this.type) {
                    case 0: // Square
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                        break;
                    case 1: // Triangle
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * Math.PI * 2 / 3) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: // All other polygons
                        const shapeSides = this.type + 3; //pentagon is type 2, but 5 sides
                        ctx.beginPath();
                        for (let i = 0; i < shapeSides; i++) {
                            const angle = (i * Math.PI * 2 / shapeSides) - Math.PI/2;
                            ctx.lineTo(
                                Math.cos(angle) * this.size/2,
                                Math.sin(angle) * this.size/2
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                }

                ctx.restore();
              
                // Draw health bar
                    const healthBarWidth = this.size;
                    const healthBarHeight = 5;
                    const healthPercentage = this.health / shapehealths[this.type];
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2 - 2,//-2 so that black bar bigger than blue
                        screenY + healthBarWidth / 2 + 15 - 2,
                        healthBarWidth + 4,//+4 so that black bar bigger
                        healthBarHeight + 4,
                        4
                    );//older browsers might not have roundrect!!!
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(
                        screenX - healthBarWidth / 2,
                        screenY + healthBarWidth / 2 + 15,
                        healthBarWidth * healthPercentage,
                        healthBarHeight,
                        4
                    );
                    ctx.fill();
                numberOfObjectsDrawn++;
            }

            isOnScreen(x, y) {
                return x + this.size > 0 && x - this.size < canvas.width &&
                       y + this.size > 0 && y - this.size < canvas.height;
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color, outline) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.outline = outline;
                //this.radius = Math.random() * 3 + 1;
                this.radius = Math.random() * 5 + 10;
                this.dx = (Math.random() - 0.5) * 5;
                this.dy = (Math.random() - 0.5) * 5;
                this.lifetime = 40 + Math.random() * 10;
                this.alpha = 1;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.lifetime--;
                //this.alpha = this.lifetime / 60;
                if (this.lifetime < 25){
                  this.alpha-=0.05;
                  if (this.alpha < 0){this.alpha = 0;}
                }
                return this.lifetime <= 0;
            }

            draw() {
                // Convert world coordinates to screen coordinates
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                
                // Only draw if on screen
                if (screenX + this.radius > 0 && screenX - this.radius < canvas.width &&
                    screenY + this.radius > 0 && screenY - this.radius < canvas.height) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.outline;
                    ctx.strokeStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    numberOfObjectsDrawn++;
                }
            }
        }

        function createParticles(x, y, color, outline, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, outline));
            }
        }

        function spawnEnemy() {
            enemies.push(new Enemy());
        }
        
        function drawGrid() {
            ctx.strokeStyle = GRID_LINE_COLOR;
            ctx.lineWidth = 4;
            
            // Calculate visible grid area
            const startX = Math.floor(cameraX / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(cameraY / GRID_SIZE) * GRID_SIZE;
            
            const endX = Math.min(MAP_WIDTH, startX + canvas.width + GRID_SIZE);
            const endY = Math.min(MAP_HEIGHT, startY + canvas.height + GRID_SIZE);
            
            // Draw vertical lines
            for (let x = startX; x <= endX; x += GRID_SIZE) {
                const screenX = x - cameraX;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = startY; y <= endY; y += GRID_SIZE) {
                const screenY = y - cameraY;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
        }
      
        function drawMapBoundary() {// Draw area outside the map (where camera can go beyond)
            ctx.save();
            ctx.fillStyle = 'rgba(95, 103, 108, 0.5)';
            // Top border
            ctx.fillRect(-cameraX-canvas.width/2,-cameraY,MAP_WIDTH+canvas.width,Math.min(0, cameraY));//Math.min so that only draw if cameraY < 0
            // Bottom border
            ctx.fillRect(-cameraX-canvas.width/2,MAP_HEIGHT - cameraY,MAP_WIDTH+canvas.width,canvas.height);
            // Left border
            ctx.fillRect(-cameraX,-cameraY,Math.min(0, cameraX),MAP_HEIGHT);//only draw if cameraX < 0
            // Right border
            ctx.fillRect(MAP_WIDTH - cameraX,-cameraY,canvas.width,MAP_HEIGHT);
            ctx.restore();
        }
      
        function drawMinimap() {
            //draw the minimap at top left corner of screen
            let mmX = 10;
            let mmY = 10;
            let mmWidth = 150/1000*canvas.height;
            let mmHeight = 150/1000*canvas.height;//size scaling depending on height of browser
            //if rectangular map instad of square
            if (MAP_WIDTH > MAP_HEIGHT){
              mmWidth = mmWidth/MAP_HEIGHT*MAP_WIDTH;
            }
            if (MAP_WIDTH < MAP_HEIGHT){
              mmHeight = mmHeight/MAP_WIDTH*MAP_HEIGHT;
            }
            ctx.fillStyle = "rgba(189,189,189,.5)";
            ctx.strokeStyle = "rgb(90,90,90)";
            ctx.lineWidth = 5/1000*canvas.height;//size scaling depending on height of browser
            ctx.fillRect(mmX, mmY, mmWidth, mmHeight);
            ctx.strokeRect(mmX, mmY, mmWidth, mmHeight);
            //player location on minimap
            ctx.fillStyle = "rgb(90,90,90)"; //player always darkgrey triangle on minimap
            if (players.length > 0) {
                const player = players[0];
                ctx.save();
                ctx.translate((player.x / MAP_WIDTH) * mmWidth + mmX, (player.y / MAP_HEIGHT) * mmHeight + mmY);
                ctx.rotate(player.angle+90/180*Math.PI);//traingle code draws it 90 degrees sideways (note that everything is in radians, not degrees)
                ctx.beginPath();//draw triangle
                let h = 10;
                let w = 7;
                ctx.moveTo(0,-h/2)
                ctx.lineTo(w/2,h/2)
                ctx.lineTo(-w/2,h/2)
                ctx.fill();
                ctx.restore();
            }
        }
      
        function drawGridHomeScreen() {//ONLY FOR HOMSCREEN
            hctx.strokeStyle = GRID_LINE_COLOR;
            hctx.lineWidth = 4;
            const startX = Math.floor(hsCameraX / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(hsCameraY / GRID_SIZE) * GRID_SIZE;
            const endX = Math.min(hsMAP_SIZE, startX + hcanvas.width + GRID_SIZE);
            const endY = Math.min(hsMAP_SIZE, startY + hcanvas.height + GRID_SIZE);
            
            // Draw vertical lines
            for (let x = startX; x <= endX; x += GRID_SIZE) {
                const screenX = x - hsCameraX;
                hctx.beginPath();
                hctx.moveTo(screenX, 0);
                hctx.lineTo(screenX, hcanvas.height);
                hctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = startY; y <= endY; y += GRID_SIZE) {
                const screenY = y - hsCameraY;
                hctx.beginPath();
                hctx.moveTo(0, screenY);
                hctx.lineTo(hcanvas.width, screenY);
                hctx.stroke();
            }
        }

        // Mouse tracking (now in screen coordinates)
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            checkForKeybinds(e.key);
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
      
        function checkForKeybinds(key){//pressed a key, check if the key represents anything (except player movement)
          if (key == "m" && players.length > 0){//if ingame and press m
            if (debugState == "open"){//close the debug
              fpsCounter.style.display = "none";
              let allOtherDebugDivs = document.querySelectorAll(".debugopen");
              for(let i = 0; i < allOtherDebugDivs.length; i++){
                document.getElementById(allOtherDebugDivs[i].id).className = "debug";
              }
              debugState = "close";
            }
            else {//open the debug
              fpsCounter.style.display = "block";
              let allOtherDebugDivs = document.querySelectorAll(".debug");
              for(let i = 0; i < allOtherDebugDivs.length; i++){
                document.getElementById(allOtherDebugDivs[i].id).className = "debugopen";
              }
              debugState = "open";
            }
          }
        }
      
        function spawnShape() {
            shapes.push(new Shape(
                Math.random() * MAP_WIDTH,
                Math.random() * MAP_HEIGHT
            ));
        }
      
        function showDeathScreen(finalScore) {
            isGamePaused = true;
            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('deathScreen').classList.remove('hidden');
        }

        function restartGame() {
            document.getElementById('deathScreen').classList.add('hidden');
            resetGame();
            isGamePaused = false;
            gameLoop();//restart the screen updates
        }

        function resetGame() {
            // Clear all game objects
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;

            // Reset player
            if (players.length > 0) {
                players[0].x = MAP_WIDTH / 2;
                players[0].y = MAP_HEIGHT / 2;
                players[0].health = 100;
                players[0].score = 0;
            } else {
                players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            }

            // Reset score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;

            // Spawn initial enemies
            for (let i = 0; i < MAX_BOTS; i++) {
                spawnEnemy();
            }
        }

        // Game initialization
        function init() {
            players.push(new Player(MAP_WIDTH / 2, MAP_HEIGHT / 2));
            createParticles(MAP_WIDTH / 2, MAP_HEIGHT / 2, players[0].color, players[0].outline, 15);
            
            // Spawn initial enemies
            for (let i = 0; i < MAX_BOTS; i++) {
                spawnEnemy();
            }
            
            // Spawn initial shapes
            for (let i = 0; i < MAX_SHAPES; i++) {
                spawnShape();
            }
            
            // Update map size display
            mapSizeElement.textContent = `Map: ${MAP_WIDTH}x${MAP_HEIGHT}`;
            botnumberElement.textContent = `Number of enemies: ${MAX_BOTS}`;
            shapenumberElement.textContent = `Number of shapes: ${MAX_SHAPES}`;
            dimensionElement.textContent = `Dimension: ${gamemode}`;
            document.getElementById('restartButton').addEventListener('click', restartGame);
            document.getElementById('continueButton').addEventListener('click', returnToHomeScreen);
        }

        // Game loop
        function gameLoop() {
            if (isGamePaused) return;//dont do anything if at death screen
            numberOfObjectsDrawn = 0;
            // Clear canvas by drawing over
            ctx.fillStyle = '#CDCDCD';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawMapBoundary();//draw area outside map (translucent rectangles so that grids also change color)
          
            // Update and draw shapes first, so that they will be drawn below everything else
            shapes.forEach(shape => {
                shape.update();
                shape.draw();
            });
            
            // Update enemies
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            // Update and draw all game objects
            players.forEach(player => {
                player.update();
                player.draw();
            });

            // Update bullets and remove dead ones
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update() && bullets.splice(i, 1);
            }
            bullets.forEach(bullet => bullet.draw());

            // Update particles and remove dead ones (draw particles last so that they are above everything else)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update() && particles.splice(i, 1);
            }
            particles.forEach(particle => particle.draw());

            // Occasionally spawn new enemies
            if (Math.random() < 0.01 && enemies.length < MAX_BOTS) {
                spawnEnemy();
            }
          
            //if debug is open, and if dimension is not crossroads or cavern:
            drawMinimap()
          
            //update debug
            let newtext = `Drawn Entities: ${numberOfObjectsDrawn}`;
            if (drawnentitiesElement.textContent != newtext){//dont update debug 60 times per second, only update when needed (idk if this will change the performance or not)
              drawnentitiesElement.textContent = newtext;
            }
          
            // FPS counter update
            frameCount++;
            const now = performance.now();
            if (now >= lastFpsUpdate + 1000) { // Update every second
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                fpsCounter.textContent = `FPS: ${fps}`;
                fpsCounter.className = 
                  fps >= 60 ? 'high' : 
                  fps >= 30 ? 'medium' : 'low';
            }

            requestAnimationFrame(gameLoop);
        }
      
        function drawPolygon(sides,x,y,rot){//only for home screen background
            let shapetype = sides-3;
            if (sides == 4){//square and triangle are the anomalies that dont follow the sides
              shapetype = 0;
            }
            else if (sides == 3){
              shapetype = 1;
            }
            const size = shapesizes[shapetype];
            hctx.save();
            hctx.translate(x-hsCameraX, y-hsCameraY);
            hctx.rotate(rot/180*Math.PI);
            hctx.fillStyle = shapecolors[shapetype];
            hctx.strokeStyle = shapeoutlines[shapetype];
            hctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i * Math.PI * 2 / sides) - Math.PI/2;
                hctx.lineTo(Math.cos(angle) * size/2,Math.sin(angle) * size/2);
            }
            hctx.closePath();
            hctx.fill();
            hctx.stroke();
            hctx.restore();
        }
      
        //drawing canvas for homescreen background
        function homeScreenLoop() {
            if (players.length > 0) return;//dont do anything if ingame
            //start drawing the homescreen if not ingame
            hctx.fillStyle = '#CDCDCD';
            hctx.fillRect(0, 0, hcanvas.width, hcanvas.height);
            drawGridHomeScreen();//(no need draw boundary of map)
            //now draw the stuff
            if (gamemode == "PvE arena"){
              hctx.lineJoin = "round";//to make shape corners round
              hctx.lineWidth = 4;
              //drawPolygon(sides,x,y,rot)
              //map size is 3000
              drawPolygon(11,2276,1677,0)
              drawPolygon(9,1500,1500,0)
              drawPolygon(8,776,1450,0)
              drawPolygon(7,776,1050,0)
              drawPolygon(6,1790,1069,0)
              drawPolygon(5,1399,1997,0)
              drawPolygon(4,1784,1967,0)
              drawPolygon(3,776,1910,0)
              drawPolygon(3,1046,1288,0)
              drawPolygon(3,2790,2069,0)
            }
          
            hctx.fillStyle = 'rgba(0,0,0,.5)';//make homescreen background darker
            hctx.fillRect(0, 0, hcanvas.width, hcanvas.height);
            //now move the camera
            hsCameraX = hsMAP_SIZE/2 + rotationRadius*Math.cos(rotationAngle/180*Math.PI) - canvas.width / 2;
            hsCameraY = hsMAP_SIZE/2 + rotationRadius*Math.sin(rotationAngle/180*Math.PI) - canvas.height / 2;
            //rotationAngle++;//good for testing
            rotationAngle+=0.2;
            if(rotationAngle>=360){
              rotationAngle-=360;
            }

            requestAnimationFrame(homeScreenLoop);
        }
        homeScreenLoop();

        document.getElementById('playButton').addEventListener('click', startGame);
        function startGame(){
          // First time start game
          //remove home screen divs
          document.getElementById('playButton').style.display = "none";
          hcanvas.style.display = "none";
          document.getElementById('display-name-input').style.display = "none";
          document.getElementById('connecting').style.display = "none";
          changelogPreview.style.display = "none";
          document.getElementById('hometitle').style.display = "none";
          subtitle.style.display = "none";
          document.getElementById('subsubtitle').style.display = "none";
          document.getElementById('gamemodeSelector').style.display = "none";
          document.getElementById('left-buttons').style.display = "none";
          document.getElementById('top-buttons').style.display = "none";
          document.getElementById('right-buttons').style.display = "none";
          //add game divs
          document.getElementById('score').style.display = "block";
          //open debug
          fpsCounter.style.display = "block";
          let allOtherDebugDivs = document.querySelectorAll(".debug");
          for(let i = 0; i < allOtherDebugDivs.length; i++){
            document.getElementById(allOtherDebugDivs[i].id).className = "debugopen";
          }
          debugState = "open";
          //start the game
          init();
          gameLoop();
        }
        function loadChangelog() {//copied from scenexe2 code, thanks cobalt
          return new Promise(function (AS) {
            fetch("/changelog.txt").then(function (AU) {
              return AU.text();
            }).then(function (AU) {
              (function (AP) {
                var AR = "";
                for (var AQ = ("CHANGELOG - " + (WI = AP.split("\n\r\n"))[0]).split("\n"), AB = 0; AB < AQ.length; AB++) {
                  if (!AQ[AB].startsWith("    ")) {
                    AR += AR == "" ? AQ[AB] : "<br />" + AQ[AB];
                  }
                }//get the first paragraph (latest version update) (version updates are separated by an empty line in the changelog txt file)
                let additionaltext = "<br>you can view the full changelog ";//leave a blank space cuz we're adding a word after that
                changelogPreview.innerHTML = AR.replace(/\n/g, "<br />") + additionaltext;//replace text new line with html new line, and add to the div
                
                const hereButton = document.createElement("div");
                hereButton.innerText = "here";
                hereButton.id = "openChangelogButton";
                changelogPreview.appendChild(hereButton);
                hereButton.addEventListener("click", () => {
                  fullchangelog.style.display = "block";
                });
                
                subtitle.textContent = WI[0].split("-", 1)[0].trim();//add the version no. to subtitle div
                //now fix the entire changelog text
                AR = "";
                for (var AX = 0; AX < WI.length; AX++) {
                  if (AR != "") {
                    AR += "<br /><br /><hr />";//add horizontal line in changelog
                  }
                  for (var AF = WI[AX].split("\n"), Az = 0; Az < AF.length; Az++) {
                    var Aj = 0;
                    var S0 = "";
                    for (Aj = 0; AF[Az].startsWith("    ", Aj * 4); Aj++) {
                      S0 += "&emsp;&emsp;";//add paragraph indentation in changelog
                    }
                    if (Az == 0) {
                      AR += "<h3>";//font size
                    } else if (AR != "" && Az != 1) {
                      AR += "<br />";//new line
                    }
                    AR += S0 + AF[Az];
                    if (Az == 0) {
                      AR += "</h3>";
                    }
                  }
                }
                fullchangelog.children[0].children[2].innerHTML = AR.replace(/\n/g, "<br />");
              })(AU.replace(/\r?\n/g, "\r\n"));
              AS();
            });
          });
        }
        loadChangelog();
      
        function accounts(){//not ready yet
          document.getElementById('modal').style.display = "block";
          document.getElementById('blackScreen').style.display = "block";
        }
        function bugs(){//ingame method to report bugs, not ready yet
          document.getElementById('modal2').style.display = "block";
          document.getElementById('blackScreen').style.display = "block";
        }
        function closeModal(){
          document.getElementById('modal').style.display = "none";
          document.getElementById('blackScreen').style.display = "none";
        }
        function closeModal2(){
          document.getElementById('modal2').style.display = "none";
          document.getElementById('blackScreen').style.display = "none";
        }
        function returnToHomeScreen(){//return from death screen to home screen
          document.getElementById('playButton').style.display = "block";
          hcanvas.style.display = "block";
          document.getElementById('display-name-input').style.display = "block";
          //document.getElementById('connecting').style.display = "block";
          changelogPreview.style.display = "block";
          document.getElementById('hometitle').style.display = "block";
          subtitle.style.display = "block";
          document.getElementById('subsubtitle').style.display = "block";
          document.getElementById('gamemodeSelector').style.display = "block";
          document.getElementById('left-buttons').style.display = "block";
          document.getElementById('top-buttons').style.display = "block";
          document.getElementById('right-buttons').style.display = "block";
          document.getElementById('score').style.display = "none";
          fpsCounter.style.display = "none";
          let allOtherDebugDivs = document.querySelectorAll(".debug");
          for(let i = 0; i < allOtherDebugDivs.length; i++){
            document.getElementById(allOtherDebugDivs[i].id).className = "debug";
          }
          debugState = "close";
          document.getElementById('deathScreen').classList.add('hidden');
        }
    </script>
</body>
</html>